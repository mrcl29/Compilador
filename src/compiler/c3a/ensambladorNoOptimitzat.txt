*----------------------------------------------------------- 
* Title      : Codi Ensamblador 68K
* Written by : Marc Llobera Villalonga
* Description: Codi ensamblador generat per el compilador
*              de Marc Llobera per a la prÃ ctica de 
*              l'assignatura de Compiladors. 
*----------------------------------------------------------- 
    ORG    $1000 
START:                  ; first instruction of program 


    ; t0 = 1
    MOVE.L    #1, D0 
    MOVE.L    D0, 0(A7) 

    ; t1 = 100
    MOVE.L    #100, D0 
    MOVE.L    D0, 4(A7) 

    ; t2 = t0
    MOVE.L    0(A7), D0 
    MOVE.L    D0, 8(A7) 

    ; goto e1
    BRA       E1 

    ; e0
E0: 

    ; t3 = t1
    MOVE.L    4(A7), D0 
    MOVE.L    D0, 12(A7) 

    ; t4 = 1
    MOVE.L    #1, D0 
    MOVE.L    D0, 16(A7) 

    ; t2 = t2 + t4
    MOVE.L    8(A7), D0 
    MOVE.L    16(A7), D1 
    ADD.L     D1, D0 
    MOVE.L    D0, 8(A7) 

    ; if t2 >= t3 then goto e2 
    MOVE.L    8(A7), D0 
    MOVE.L    12(A7), D1 
    CMP.L     D1, D0 
    BGE       E2 

    ; e1
E1: 

    ; t5 = 1
    MOVE.L    #1, D0 
    MOVE.L    D0, 20(A7) 

    ; t6 = t2
    MOVE.L    8(A7), D0 
    MOVE.L    D0, 24(A7) 

    ; out(t6 :: t5) 
    MOVE.L    20(A7), D0 
    MOVE.L    24(A7), D1 
    CMP.L     #1, D0 
    BNE       E4   
    JSR       PRINT_INTEGER   
    BRA       E3   
E4:   
    CMP.L     #2, D0 
    BNE       E5   
    JSR       PRINT_BOOLEAN   
    BRA       E3   
E5:   
    LEA       ERROR_MSG, A1 
    MOVE.W  #14, D0 
    TRAP    #15 
E3: 

    ; goto e0
    BRA       E0 

    ; e2
E2: 

; FINAL 

END: 
    SIMHALT 
PRINT_INTEGER: 
    MOVE.L  D1, D2 
    LEA     BUFFER, A0 
    JSR     INT_TO_STR 
    BRA     PRINT_STRING 
PRINT_BOOLEAN: 
    CMP.L   #-1, D1 
    BEQ     PRINT_TRUE 
    CMP.L   #0, D1 
    BEQ     PRINT_FALSE 
    LEA     ERROR_MSG, A1 
    MOVE.W  #14, D0 
    TRAP    #15 
    RTS   
PRINT_TRUE: 
    LEA     TRUE_MSG, A1 
    MOVE.W  #14, D0 
    TRAP    #15 
    RTS   
PRINT_FALSE: 
    LEA     FALSE_MSG, A1 
    MOVE.W  #14, D0 
    TRAP    #15 
    RTS   
PRINT_STRING: 
    MOVE.L  A0, A1 
    MOVE.W  #14, D0 
    TRAP    #15 
    LEA     NEWLINE, A1 
    MOVE.W  #14, D0 
    TRAP    #15 
    RTS 
INT_TO_STR: 
    LEA     BUFFER+10, A1 
    CLR.B   (A1) 
    MOVE.L  D2, D3 
    TST.L   D3 
    BPL     POSITIVE 
    NEG.L   D3 
    MOVE.B  #'-', D4 
POSITIVE: 
    MOVE.B  #0, D5 
CONVERT_LOOP: 
    DIVU    #10, D3 
    SWAP    D3 
    ADD.B   #'0', D3 
    MOVE.B  D3, -(A1) 
    CLR.W   D3 
    SWAP    D3 
    ADDQ.B  #1, D5 
    TST.L   D3 
    BNE     CONVERT_LOOP 
    TST.B   D4 
    BEQ     NO_SIGN 
    MOVE.B  D4, -(A1) 
NO_SIGN: 
    MOVE.L  A1, A0 
    RTS 
VALIDATE_INPUT: 
    CMP.B   #1, D0 
    BEQ     INTEGER_INPUT 
    CMP.B   #2, D0 
    BEQ     BOOLEAN_INPUT 
    RTS 
INTEGER_INPUT: 
    LEA     PROMPT_INT, A0 
    JSR     PRINT_STRING 
    JSR     READ_STRING 
    JSR     CONVERT_TO_INT 
    TST.B   D1 
    BEQ     VALID_INT 
    LEA     ERROR_MSG, A0 
    JSR     PRINT_STRING 
    MOVE.L  #0, D1 
    RTS 
VALID_INT: 
    MOVE.L  D2, D1 
    RTS 
BOOLEAN_INPUT: 
    LEA     PROMPT_BOOL, A0 
    JSR     PRINT_STRING 
    JSR     READ_STRING 
    JSR     CONVERT_TO_BOOL 
    TST.B   D1 
    BEQ     VALID_BOOL 
    LEA     ERROR_MSG, A0 
    JSR     PRINT_STRING 
    MOVE.L  #0, D1 
    RTS 
VALID_BOOL: 
    MOVE.L  D2, D1  
    RTS 
READ_STRING: 
    LEA     INPUT_BUFFER, A1  
READ_LOOP: 
    MOVE.W  #5, D0 
    TRAP    #15 
    CMP.B   #$0D, D1  
    BEQ     READ_DONE  
    MOVE.B  D1, (A1)+  
    BRA     READ_LOOP  
READ_DONE: 
    CLR.B   (A1)  
    RTS  
CONVERT_TO_INT: 
    CLR.L   D2  
    CLR.B   D3  
    LEA     INPUT_BUFFER, A1 
    MOVE.B  (A1), D1  
    CMP.B   #'-', D1   
    BNE     CONVERT_INT_LOOP  
    MOVE.B  #1, D3    
    ADDQ.L  #1, A1   
CONVERT_INT_LOOP: 
    MOVE.B  (A1)+, D1  
    BEQ     CONVERT_INT_DONE  
    CMP.B   #'0', D1  
    BLT     INVALID_INPUT  
    CMP.B   #'9', D1    
    BGT     INVALID_INPUT 
    SUB.B   #'0', D1  
    MULU.W  #10, D2   
    ADD.L   D1, D2  
    BRA     CONVERT_INT_LOOP  
CONVERT_INT_DONE: 
    TST.B   D3  
    BEQ     POSITIVE_NUMBER  
    NEG.L   D2 
POSITIVE_NUMBER: 
    CLR.B   D1   
    RTS  
INVALID_INPUT: 
    MOVE.B  #1, D1   
    RTS    
CONVERT_TO_BOOL: 
    LEA     INPUT_BUFFER, A1 
    MOVE.B  (A1)+, D1  
    CMP.B   #'T', D1   
    BEQ     CHECK_TRUE 
    CMP.B   #'F', D1    
    BEQ     CHECK_FALSE   
    BRA     INVALID_INPUT  
CHECK_TRUE: 
    MOVE.B  (A1)+, D1 
    CMP.B   #'R', D1 
    BNE     INVALID_INPUT 
    MOVE.B  (A1)+, D1         
    CMP.B   #'U', D1  
    BNE     INVALID_INPUT   
    MOVE.B  (A1)+, D1    
    CMP.B   #'E', D1 
    BNE     INVALID_INPUT  
    MOVE.L  #-1, D2  
    CLR.B   D1  
    RTS 
CHECK_FALSE: 
    MOVE.B  (A1)+, D1 
    CMP.B   #'A', D1  
    BNE     INVALID_INPUT  
    MOVE.B  (A1)+, D1  
    CMP.B   #'L', D1   
    BNE     INVALID_INPUT  
    MOVE.B  (A1)+, D1  
    CMP.B   #'S', D1   
    BNE     INVALID_INPUT  
    MOVE.B  (A1)+, D1  
    CMP.B   #'E', D1  
    BNE     INVALID_INPUT   
    CLR.L   D2  
    CLR.B   D1   
    RTS 
CR           EQU     $0D 
LF           EQU     $0A 
TRUE_MSG     DC.B    'TRUE',CR,LF, 0 
FALSE_MSG    DC.B    'FALSE',CR,LF, 0 
ERROR_MSG    DC.B    'ERROR',CR,LF, 0 
NEWLINE      DC.B    ' ',CR,LF, 0  
BUFFER       DS.B    20 
PROMPT_INT   DC.B    'Enter an integer: ', 0 
PROMPT_BOOL  DC.B    'Enter a boolean (TRUE/FALSE): ', 0 
INPUT_BUFFER DS.B    100 
    END    START 
