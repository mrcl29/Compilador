
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package compiler.sintactic;

import java.lang.Exception;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import compiler.sintactic.Symbols.*;
import compiler.c3a.*;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\113\000\002\002\004\000\002\002\003\000\002\003" +
    "\003\000\002\003\002\000\002\004\004\000\002\004\004" +
    "\000\002\004\003\000\002\016\003\000\002\016\003\000" +
    "\002\016\003\000\002\016\003\000\002\016\003\000\002" +
    "\016\003\000\002\016\003\000\002\005\003\000\002\005" +
    "\003\000\002\005\003\000\002\017\006\000\002\017\006" +
    "\000\002\020\014\000\002\020\011\000\002\021\011\000" +
    "\002\022\011\000\002\023\005\000\002\023\003\000\002" +
    "\024\003\000\002\024\003\000\002\025\007\000\002\044" +
    "\003\000\002\044\003\000\002\044\003\000\002\044\003" +
    "\000\002\026\007\000\002\026\006\000\002\027\006\000" +
    "\002\027\005\000\002\011\014\000\002\011\013\000\002" +
    "\014\004\000\002\014\003\000\002\015\007\000\002\006" +
    "\011\000\002\007\011\000\002\010\013\000\002\033\003" +
    "\000\002\033\003\000\002\033\003\000\002\033\003\000" +
    "\002\033\003\000\002\040\003\000\002\040\003\000\002" +
    "\041\003\000\002\041\004\000\002\042\003\000\002\043" +
    "\003\000\002\037\006\000\002\032\003\000\002\032\003" +
    "\000\002\030\004\000\002\031\005\000\002\031\002\000" +
    "\002\012\003\000\002\012\005\000\002\012\002\000\002" +
    "\013\005\000\002\036\005\000\002\036\005\000\002\036" +
    "\005\000\002\036\005\000\002\035\005\000\002\035\005" +
    "\000\002\045\006\000\002\034\003\000\002\034\003\000" +
    "\002\034\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\251\000\030\002\ufffe\004\012\007\035\010\007\011" +
    "\034\014\005\016\015\022\026\023\022\051\024\052\021" +
    "\001\002\000\040\004\ufff1\006\ufff1\007\ufff1\010\ufff1\011" +
    "\ufff1\012\ufff1\013\ufff1\014\ufff1\015\ufff1\016\ufff1\020\ufff1" +
    "\022\ufff1\023\ufff1\051\ufff1\052\ufff1\001\002\000\004\035" +
    "\246\001\002\000\040\004\ufff4\006\ufff4\007\ufff4\010\ufff4" +
    "\011\ufff4\012\ufff4\013\ufff4\014\ufff4\015\ufff4\016\ufff4\020" +
    "\ufff4\022\ufff4\023\ufff4\051\ufff4\052\ufff4\001\002\000\004" +
    "\051\240\001\002\000\040\004\ufff6\006\ufff6\007\ufff6\010" +
    "\ufff6\011\ufff6\012\ufff6\013\ufff6\014\ufff6\015\ufff6\016\ufff6" +
    "\020\ufff6\022\ufff6\023\ufff6\051\ufff6\052\ufff6\001\002\000" +
    "\004\002\237\001\002\000\006\024\041\025\040\001\002" +
    "\000\026\004\012\007\035\010\007\011\034\014\005\016" +
    "\015\022\026\023\022\051\024\052\021\001\002\000\004" +
    "\002\000\001\002\000\014\021\056\030\050\047\063\050" +
    "\052\051\175\001\002\000\040\004\ufff7\006\ufff7\007\ufff7" +
    "\010\ufff7\011\ufff7\012\ufff7\013\ufff7\014\ufff7\015\ufff7\016" +
    "\ufff7\020\ufff7\022\ufff7\023\ufff7\051\ufff7\052\ufff7\001\002" +
    "\000\040\004\ufff9\006\ufff9\007\ufff9\010\ufff9\011\ufff9\012" +
    "\ufff9\013\ufff9\014\ufff9\015\ufff9\016\ufff9\020\ufff9\022\ufff9" +
    "\023\ufff9\051\ufff9\052\ufff9\001\002\000\040\004\ufffa\006" +
    "\ufffa\007\ufffa\010\ufffa\011\ufffa\012\ufffa\013\ufffa\014\ufffa" +
    "\015\ufffa\016\ufffa\020\ufffa\022\ufffa\023\ufffa\051\ufffa\052" +
    "\ufffa\001\002\000\004\002\ufffb\001\002\000\004\051\163" +
    "\001\002\000\040\004\ufff8\006\ufff8\007\ufff8\010\ufff8\011" +
    "\ufff8\012\ufff8\013\ufff8\014\ufff8\015\ufff8\016\ufff8\020\ufff8" +
    "\022\ufff8\023\ufff8\051\ufff8\052\ufff8\001\002\000\010\026" +
    "\152\035\153\045\105\001\002\000\026\004\012\007\035" +
    "\010\007\011\034\014\005\016\015\022\026\023\022\051" +
    "\024\052\021\001\002\000\004\035\140\001\002\000\004" +
    "\002\uffff\001\002\000\040\004\ufff2\006\ufff2\007\ufff2\010" +
    "\ufff2\011\ufff2\012\ufff2\013\ufff2\014\ufff2\015\ufff2\016\ufff2" +
    "\020\ufff2\022\ufff2\023\ufff2\051\ufff2\052\ufff2\001\002\000" +
    "\040\004\ufff3\006\ufff3\007\ufff3\010\ufff3\011\ufff3\012\ufff3" +
    "\013\ufff3\014\ufff3\015\ufff3\016\ufff3\020\ufff3\022\ufff3\023" +
    "\ufff3\051\ufff3\052\ufff3\001\002\000\040\004\ufff5\006\ufff5" +
    "\007\ufff5\010\ufff5\011\ufff5\012\ufff5\013\ufff5\014\ufff5\015" +
    "\ufff5\016\ufff5\020\ufff5\022\ufff5\023\ufff5\051\ufff5\052\ufff5" +
    "\001\002\000\004\026\135\001\002\000\004\035\121\001" +
    "\002\000\004\051\036\001\002\000\004\040\037\001\002" +
    "\000\006\024\041\025\040\001\002\000\016\026\uffc8\036" +
    "\uffc8\037\uffc8\042\uffc8\044\uffc8\051\uffc8\001\002\000\016" +
    "\026\uffc9\036\uffc9\037\uffc9\042\uffc9\044\uffc9\051\uffc9\001" +
    "\002\000\004\026\043\001\002\000\014\021\056\030\050" +
    "\047\063\050\052\051\046\001\002\000\030\017\uffce\027" +
    "\uffce\030\uffce\031\uffce\032\uffce\033\uffce\034\uffce\036\uffce" +
    "\037\uffce\041\uffce\042\uffce\001\002\000\030\017\uffd3\027" +
    "\uffd3\030\uffd3\031\uffd3\032\uffd3\033\uffd3\034\uffd3\036\uffd3" +
    "\037\uffd3\041\uffd3\042\uffd3\001\002\000\034\017\uffb9\027" +
    "\uffb9\030\uffb9\031\uffb9\032\uffb9\033\uffb9\034\uffb9\035\106" +
    "\036\uffb9\037\uffb9\041\uffb9\042\uffb9\045\105\001\002\000" +
    "\030\017\uffcf\027\uffcf\030\uffcf\031\uffcf\032\uffcf\033\uffcf" +
    "\034\uffcf\036\uffcf\037\uffcf\041\uffcf\042\uffcf\001\002\000" +
    "\004\047\063\001\002\000\030\017\uffd2\027\uffd2\030\uffd2" +
    "\031\uffd2\032\uffd2\033\uffd2\034\uffd2\036\uffd2\037\uffd2\041" +
    "\uffd2\042\uffd2\001\002\000\030\017\uffcb\027\uffcb\030\uffcb" +
    "\031\uffcb\032\uffcb\033\uffcb\034\uffcb\036\uffcb\037\uffcb\041" +
    "\uffcb\042\uffcb\001\002\000\030\017\uffd1\027\uffd1\030\uffd1" +
    "\031\uffd1\032\uffd1\033\uffd1\034\uffd1\036\uffd1\037\uffd1\041" +
    "\uffd1\042\uffd1\001\002\000\030\017\uffb8\027\uffb8\030\uffb8" +
    "\031\uffb8\032\uffb8\033\uffb8\034\uffb8\036\uffb8\037\uffb8\041" +
    "\uffb8\042\uffb8\001\002\000\030\017\uffd0\027\uffd0\030\uffd0" +
    "\031\uffd0\032\uffd0\033\uffd0\034\uffd0\036\uffd0\037\uffd0\041" +
    "\uffd0\042\uffd0\001\002\000\004\035\101\001\002\000\030" +
    "\017\uffd4\027\uffd4\030\uffd4\031\uffd4\032\uffd4\033\uffd4\034" +
    "\uffd4\036\uffd4\037\uffd4\041\uffd4\042\uffd4\001\002\000\030" +
    "\017\uffb7\027\uffb7\030\uffb7\031\uffb7\032\uffb7\033\uffb7\034" +
    "\uffb7\036\uffb7\037\uffb7\041\uffb7\042\uffb7\001\002\000\020" +
    "\027\072\030\070\031\065\032\064\033\066\034\071\041" +
    "\067\001\002\000\030\017\uffd5\027\uffd5\030\uffd5\031\uffd5" +
    "\032\uffd5\033\uffd5\034\uffd5\036\uffd5\037\uffd5\041\uffd5\042" +
    "\uffd5\001\002\000\030\017\uffcc\027\uffcc\030\uffcc\031\uffcc" +
    "\032\uffcc\033\uffcc\034\uffcc\036\uffcc\037\uffcc\041\uffcc\042" +
    "\uffcc\001\002\000\014\021\056\030\050\047\063\050\052" +
    "\051\046\001\002\000\014\021\056\030\050\047\063\050" +
    "\052\051\046\001\002\000\014\021\056\030\050\047\063" +
    "\050\052\051\046\001\002\000\040\004\uffd8\006\uffd8\007" +
    "\uffd8\010\uffd8\011\uffd8\012\uffd8\013\uffd8\014\uffd8\015\uffd8" +
    "\016\uffd8\020\uffd8\022\uffd8\023\uffd8\051\uffd8\052\uffd8\001" +
    "\002\000\014\021\056\030\050\047\063\050\052\051\046" +
    "\001\002\000\014\021\056\030\050\047\063\050\052\051" +
    "\046\001\002\000\014\021\056\030\050\047\063\050\052" +
    "\051\046\001\002\000\030\017\uffbc\027\uffbc\030\uffbc\031" +
    "\uffbc\032\uffbc\033\uffbc\034\uffbc\036\uffbc\037\uffbc\041\uffbc" +
    "\042\uffbc\001\002\000\030\017\uffbd\027\072\030\070\031" +
    "\065\032\064\033\uffbd\034\uffbd\036\uffbd\037\uffbd\041\uffbd" +
    "\042\uffbd\001\002\000\030\017\uffbb\027\uffbb\030\uffbb\031" +
    "\uffbb\032\uffbb\033\uffbb\034\uffbb\036\uffbb\037\uffbb\041\uffbb" +
    "\042\uffbb\001\002\000\030\017\uffbe\027\072\030\070\031" +
    "\065\032\064\033\uffbe\034\uffbe\036\uffbe\037\uffbe\041\uffbe" +
    "\042\uffbe\001\002\000\030\017\uffc0\027\072\030\070\031" +
    "\uffc0\032\uffc0\033\uffc0\034\uffc0\036\uffc0\037\uffc0\041\uffc0" +
    "\042\uffc0\001\002\000\030\017\uffbf\027\072\030\070\031" +
    "\uffbf\032\uffbf\033\uffbf\034\uffbf\036\uffbf\037\uffbf\041\uffbf" +
    "\042\uffbf\001\002\000\006\024\041\025\040\001\002\000" +
    "\004\036\103\001\002\000\030\017\uffba\027\uffba\030\uffba" +
    "\031\uffba\032\uffba\033\uffba\034\uffba\036\uffba\037\uffba\041" +
    "\uffba\042\uffba\001\002\000\030\017\uffcd\027\uffcd\030\uffcd" +
    "\031\uffcd\032\uffcd\033\uffcd\034\uffcd\036\uffcd\037\uffcd\041" +
    "\uffcd\042\uffcd\001\002\000\004\047\117\001\002\000\016" +
    "\021\056\030\050\036\111\047\063\050\052\051\046\001" +
    "\002\000\022\027\072\030\070\031\065\032\064\033\066" +
    "\034\071\036\uffc5\042\113\001\002\000\004\036\112\001" +
    "\002\000\030\017\uffde\027\uffde\030\uffde\031\uffde\032\uffde" +
    "\033\uffde\034\uffde\036\uffde\037\uffde\041\uffde\042\uffde\001" +
    "\002\000\030\017\uffdf\027\uffdf\030\uffdf\031\uffdf\032\uffdf" +
    "\033\uffdf\034\uffdf\036\uffdf\037\uffdf\041\uffdf\042\uffdf\001" +
    "\002\000\014\021\056\030\050\047\063\050\052\051\046" +
    "\001\002\000\004\036\uffc7\001\002\000\022\027\072\030" +
    "\070\031\065\032\064\033\066\034\071\036\uffc5\042\113" +
    "\001\002\000\004\036\uffc6\001\002\000\004\046\120\001" +
    "\002\000\032\017\uffca\026\uffca\027\uffca\030\uffca\031\uffca" +
    "\032\uffca\033\uffca\034\uffca\036\uffca\037\uffca\041\uffca\042" +
    "\uffca\001\002\000\014\021\056\030\050\047\063\050\052" +
    "\051\046\001\002\000\020\027\072\030\070\031\065\032" +
    "\064\033\066\034\071\036\123\001\002\000\004\037\124" +
    "\001\002\000\022\007\035\010\007\011\034\014\005\016" +
    "\015\022\026\023\022\051\024\001\002\000\006\012\130" +
    "\013\131\001\002\000\034\006\uffda\007\035\010\007\011" +
    "\034\012\uffda\013\uffda\014\005\015\uffda\016\015\020\uffda" +
    "\022\026\023\022\051\024\001\002\000\014\006\uffdb\012" +
    "\uffdb\013\uffdb\015\uffdb\020\uffdb\001\002\000\004\037\132" +
    "\001\002\000\040\004\uffed\006\uffed\007\uffed\010\uffed\011" +
    "\uffed\012\uffed\013\uffed\014\uffed\015\uffed\016\uffed\020\uffed" +
    "\022\uffed\023\uffed\051\uffed\052\uffed\001\002\000\022\007" +
    "\035\010\007\011\034\014\005\016\015\022\026\023\022" +
    "\051\024\001\002\000\004\013\134\001\002\000\040\004" +
    "\uffee\006\uffee\007\uffee\010\uffee\011\uffee\012\uffee\013\uffee" +
    "\014\uffee\015\uffee\016\uffee\020\uffee\022\uffee\023\uffee\051" +
    "\uffee\052\uffee\001\002\000\014\021\056\030\050\047\063" +
    "\050\052\051\046\001\002\000\020\027\072\030\070\031" +
    "\065\032\064\033\066\034\071\041\137\001\002\000\040" +
    "\004\uffef\006\uffef\007\uffef\010\uffef\011\uffef\012\uffef\013" +
    "\uffef\014\uffef\015\uffef\016\uffef\020\uffef\022\uffef\023\uffef" +
    "\051\uffef\052\uffef\001\002\000\014\021\056\030\050\047" +
    "\063\050\052\051\046\001\002\000\020\027\uffd3\030\uffd3" +
    "\031\uffd3\032\uffd3\033\uffd3\034\uffd3\036\uffe5\001\002\000" +
    "\020\027\uffd2\030\uffd2\031\uffd2\032\uffd2\033\uffd2\034\uffd2" +
    "\036\uffe2\001\002\000\004\036\147\001\002\000\020\027" +
    "\uffd4\030\uffd4\031\uffd4\032\uffd4\033\uffd4\034\uffd4\036\uffe4" +
    "\001\002\000\016\027\072\030\070\031\065\032\064\033" +
    "\066\034\071\001\002\000\020\027\uffd5\030\uffd5\031\uffd5" +
    "\032\uffd5\033\uffd5\034\uffd5\036\uffe3\001\002\000\004\041" +
    "\150\001\002\000\040\004\uffe6\006\uffe6\007\uffe6\010\uffe6" +
    "\011\uffe6\012\uffe6\013\uffe6\014\uffe6\015\uffe6\016\uffe6\020" +
    "\uffe6\022\uffe6\023\uffe6\051\uffe6\052\uffe6\001\002\000\004" +
    "\002\ufffc\001\002\000\014\021\056\030\050\047\063\050" +
    "\052\051\046\001\002\000\016\021\056\030\050\036\155" +
    "\047\063\050\052\051\046\001\002\000\004\036\157\001" +
    "\002\000\004\041\156\001\002\000\040\004\uffe0\006\uffe0" +
    "\007\uffe0\010\uffe0\011\uffe0\012\uffe0\013\uffe0\014\uffe0\015" +
    "\uffe0\016\uffe0\020\uffe0\022\uffe0\023\uffe0\051\uffe0\052\uffe0" +
    "\001\002\000\004\041\160\001\002\000\040\004\uffe1\006" +
    "\uffe1\007\uffe1\010\uffe1\011\uffe1\012\uffe1\013\uffe1\014\uffe1" +
    "\015\uffe1\016\uffe1\020\uffe1\022\uffe1\023\uffe1\051\uffe1\052" +
    "\uffe1\001\002\000\020\027\072\030\070\031\065\032\064" +
    "\033\066\034\071\041\162\001\002\000\040\004\ufff0\006" +
    "\ufff0\007\ufff0\010\ufff0\011\ufff0\012\ufff0\013\ufff0\014\ufff0" +
    "\015\ufff0\016\ufff0\020\ufff0\022\ufff0\023\ufff0\051\ufff0\052" +
    "\ufff0\001\002\000\004\026\164\001\002\000\004\043\165" +
    "\001\002\000\006\024\041\025\040\001\002\000\004\042" +
    "\167\001\002\000\006\024\041\025\040\001\002\000\004" +
    "\044\171\001\002\000\004\041\172\001\002\000\040\004" +
    "\uffd6\006\uffd6\007\uffd6\010\uffd6\011\uffd6\012\uffd6\013\uffd6" +
    "\014\uffd6\015\uffd6\016\uffd6\020\uffd6\022\uffd6\023\uffd6\051" +
    "\uffd6\052\uffd6\001\002\000\004\017\203\001\002\000\020" +
    "\017\uffe9\027\072\030\070\031\065\032\064\033\066\034" +
    "\071\001\002\000\030\017\uffb9\027\uffb9\030\uffb9\031\uffb9" +
    "\032\uffb9\033\uffb9\034\uffb9\035\106\037\uffb9\040\201\045" +
    "\105\001\002\000\004\026\177\001\002\000\014\021\056" +
    "\030\050\047\063\050\052\051\046\001\002\000\020\017" +
    "\uffea\027\072\030\070\031\065\032\064\033\066\034\071" +
    "\001\002\000\006\024\041\025\040\001\002\000\012\026" +
    "\uffc1\036\uffc1\037\uffc1\042\uffc1\001\002\000\014\021\056" +
    "\030\050\047\063\050\052\051\175\001\002\000\020\027" +
    "\072\030\070\031\065\032\064\033\066\034\071\037\uffe7" +
    "\001\002\000\004\037\207\001\002\000\004\037\uffe8\001" +
    "\002\000\022\007\035\010\007\011\034\014\005\016\015" +
    "\022\026\023\022\051\024\001\002\000\004\020\211\001" +
    "\002\000\040\004\uffeb\006\uffeb\007\uffeb\010\uffeb\011\uffeb" +
    "\012\uffeb\013\uffeb\014\uffeb\015\uffeb\016\uffeb\020\uffeb\022" +
    "\uffeb\023\uffeb\051\uffeb\052\uffeb\001\002\000\004\002\ufffd" +
    "\001\002\000\004\051\214\001\002\000\004\035\215\001" +
    "\002\000\006\036\uffc2\051\220\001\002\000\006\036\uffc4" +
    "\042\235\001\002\000\004\036\221\001\002\000\004\040" +
    "\201\001\002\000\004\037\222\001\002\000\024\006\224" +
    "\007\035\010\007\011\034\014\005\016\015\022\026\023" +
    "\022\051\024\001\002\000\004\006\224\001\002\000\004" +
    "\035\227\001\002\000\004\005\226\001\002\000\026\004" +
    "\uffdc\007\uffdc\010\uffdc\011\uffdc\014\uffdc\016\uffdc\022\uffdc" +
    "\023\uffdc\051\uffdc\052\uffdc\001\002\000\014\021\056\030" +
    "\050\047\063\050\052\051\046\001\002\000\020\027\072" +
    "\030\070\031\065\032\064\033\066\034\071\036\231\001" +
    "\002\000\004\041\232\001\002\000\004\005\uffd9\001\002" +
    "\000\004\005\234\001\002\000\026\004\uffdd\007\uffdd\010" +
    "\uffdd\011\uffdd\014\uffdd\016\uffdd\022\uffdd\023\uffdd\051\uffdd" +
    "\052\uffdd\001\002\000\006\036\uffc2\051\220\001\002\000" +
    "\004\036\uffc3\001\002\000\004\002\001\001\002\000\004" +
    "\040\241\001\002\000\006\024\041\025\040\001\002\000" +
    "\004\026\243\001\002\000\014\021\056\030\050\047\063" +
    "\050\052\051\046\001\002\000\020\027\072\030\070\031" +
    "\065\032\064\033\066\034\071\041\245\001\002\000\040" +
    "\004\uffd7\006\uffd7\007\uffd7\010\uffd7\011\uffd7\012\uffd7\013" +
    "\uffd7\014\uffd7\015\uffd7\016\uffd7\020\uffd7\022\uffd7\023\uffd7" +
    "\051\uffd7\052\uffd7\001\002\000\014\021\056\030\050\047" +
    "\063\050\052\051\046\001\002\000\020\027\072\030\070" +
    "\031\065\032\064\033\066\034\071\036\250\001\002\000" +
    "\004\037\251\001\002\000\022\007\035\010\007\011\034" +
    "\014\005\016\015\022\026\023\022\051\024\001\002\000" +
    "\004\015\253\001\002\000\040\004\uffec\006\uffec\007\uffec" +
    "\010\uffec\011\uffec\012\uffec\013\uffec\014\uffec\015\uffec\016" +
    "\uffec\020\uffec\022\uffec\023\uffec\051\uffec\052\uffec\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\251\000\042\002\010\003\013\004\026\005\017\006" +
    "\030\007\027\010\003\011\024\016\012\017\016\020\022" +
    "\021\015\022\007\025\031\026\005\037\032\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\032" +
    "\212\001\001\000\036\004\211\005\017\006\030\007\027" +
    "\010\003\011\024\016\012\017\016\020\022\021\015\022" +
    "\007\025\031\026\005\037\032\001\001\000\002\001\001" +
    "\000\034\013\175\023\172\027\053\033\173\034\044\035" +
    "\056\036\061\037\057\040\050\041\054\042\043\043\046" +
    "\045\052\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\036\004\150\005\017\006" +
    "\030\007\027\010\003\011\024\016\012\017\016\020\022" +
    "\021\015\022\007\025\031\026\005\037\032\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\032\041" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\030\027\053\033\060\034\044\035\056\036\061" +
    "\037\057\040\050\041\054\042\043\043\046\045\052\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\042\103\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\030\027\053\033\077\034\044\035\056\036" +
    "\061\037\057\040\050\041\054\042\043\043\046\045\052" +
    "\001\001\000\030\027\053\033\076\034\044\035\056\036" +
    "\061\037\057\040\050\041\054\042\043\043\046\045\052" +
    "\001\001\000\030\027\053\033\075\034\044\035\056\036" +
    "\061\037\057\040\050\041\054\042\043\043\046\045\052" +
    "\001\001\000\002\001\001\000\030\027\053\033\074\034" +
    "\044\035\056\036\061\037\057\040\050\041\054\042\043" +
    "\043\046\045\052\001\001\000\030\027\053\033\073\034" +
    "\044\035\056\036\061\037\057\040\050\041\054\042\043" +
    "\043\046\045\052\001\001\000\030\027\053\033\072\034" +
    "\044\035\056\036\061\037\057\040\050\041\054\042\043" +
    "\043\046\045\052\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\032\101\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\032\027\053\030\107\033\106\034\044\035\056\036" +
    "\061\037\057\040\050\041\054\042\043\043\046\045\052" +
    "\001\001\000\004\031\113\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\030\027\053\033\114" +
    "\034\044\035\056\036\061\037\057\040\050\041\054\042" +
    "\043\043\046\045\052\001\001\000\002\001\001\000\004" +
    "\031\115\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\030\027\053\033\121\034\044\035\056" +
    "\036\061\037\057\040\050\041\054\042\043\043\046\045" +
    "\052\001\001\000\002\001\001\000\002\001\001\000\034" +
    "\005\017\006\030\007\027\010\003\014\124\016\125\017" +
    "\016\020\022\021\015\022\007\025\031\026\005\037\032" +
    "\001\001\000\002\001\001\000\034\005\017\006\030\007" +
    "\027\010\003\014\126\016\125\017\016\020\022\021\015" +
    "\022\007\025\031\026\005\037\032\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\034\005\017" +
    "\006\030\007\027\010\003\014\132\016\125\017\016\020" +
    "\022\021\015\022\007\025\031\026\005\037\032\001\001" +
    "\000\002\001\001\000\002\001\001\000\030\027\053\033" +
    "\135\034\044\035\056\036\061\037\057\040\050\041\054" +
    "\042\043\043\046\045\052\001\001\000\002\001\001\000" +
    "\002\001\001\000\032\027\053\033\144\034\140\035\143" +
    "\036\145\037\057\040\141\041\054\042\043\043\046\044" +
    "\142\045\052\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\030\027\053\033\160\034\044\035\056\036" +
    "\061\037\057\040\050\041\054\042\043\043\046\045\052" +
    "\001\001\000\032\027\053\030\153\033\106\034\044\035" +
    "\056\036\061\037\057\040\050\041\054\042\043\043\046" +
    "\045\052\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\032\165\001\001\000\002\001\001\000\004" +
    "\032\167\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\027\053\033\177\034" +
    "\044\035\056\036\061\037\057\040\050\041\054\042\043" +
    "\043\046\045\052\001\001\000\002\001\001\000\004\032" +
    "\201\001\001\000\002\001\001\000\034\013\205\024\204" +
    "\027\053\033\203\034\044\035\056\036\061\037\057\040" +
    "\050\041\054\042\043\043\046\045\052\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\034\005" +
    "\017\006\030\007\027\010\003\014\207\016\125\017\016" +
    "\020\022\021\015\022\007\025\031\026\005\037\032\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\012\216\013" +
    "\215\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\036\005\017\006\030\007" +
    "\027\010\003\014\222\015\224\016\125\017\016\020\022" +
    "\021\015\022\007\025\031\026\005\037\032\001\001\000" +
    "\004\015\232\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\030\027\053\033\227\034\044\035" +
    "\056\036\061\037\057\040\050\041\054\042\043\043\046" +
    "\045\052\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\012\235\013\215\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\032\241\001\001\000\002" +
    "\001\001\000\030\027\053\033\243\034\044\035\056\036" +
    "\061\037\057\040\050\041\054\042\043\043\046\045\052" +
    "\001\001\000\002\001\001\000\002\001\001\000\030\027" +
    "\053\033\246\034\044\035\056\036\061\037\057\040\050" +
    "\041\054\042\043\043\046\045\052\001\001\000\002\001" +
    "\001\000\002\001\001\000\034\005\017\006\030\007\027" +
    "\010\003\014\251\016\125\017\016\020\022\021\015\022" +
    "\007\025\031\026\005\037\032\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/

    TaulaSimbols taulaSimbols = new TaulaSimbols();

    public boolean error_detectat = false;

    public boolean DEBUG = false;
    public void print_this(Object msg){
        if(DEBUG){
            System.out.println(msg);
        }
    }

    GenerarCodi c3a = new GenerarCodi();

    int nbytes = 2;
    int buid = -2;

    /**************************************************************
    ************************ GESTIÓ ERRORS ************************
    **************************************************************/

    @Override
    public void syntax_error(Symbol s) {
        report_error("Error sintáctico", s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        report_error("Error sintáctico inrrecuperable", s);
        done_parsing();
    }

    @Override
    public void report_error(String t, Object info) {
        print_this("Reportando error...");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();

            print_error("Error en la linea " + l.getLine() + " y columna " + l.getColumn() + ": " + info.toString() + " --> " + t);
        }else{
            print_error("info no es Symbol en report_error");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal ("+message+")", info);
        done_parsing();
    }

    /**
    * Mètode per mostrar un error semàntic
    **/
    public void semantic_error(String t, Object info){
        if(info instanceof Simbol){
            Simbol token = (Simbol) info;

            print_error("Error semántico en la linea " + token.getFila() + " y columna " + token.getColumna() + " --> " + t);
        }else{
            print_error("info no es Symbol en semantic_error");
        }
        done_parsing();
    }

    /**
    * Mètode per mostrar un error
    **/
    public void print_error(String msg){
        error_detectat = true;
        System.err.println("Error--> " + msg);
        done_parsing();
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= S EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // S ::= P 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("S",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // P ::= BODY 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("P",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // P ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("P",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // BODY ::= SENT BODY 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BODY",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // BODY ::= FUNC_DECL BODY 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BODY",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // BODY ::= eof 
            {
              Object RESULT =null;
		 done_parsing(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BODY",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // SENT ::= DECL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // SENT ::= ASIG_SENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // SENT ::= IF_SENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // SENT ::= WHILE_SENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // SENT ::= FOR_SENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // SENT ::= SAL_SENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // SENT ::= CRID_FUNC_SENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // DECL ::= VAR_DECL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // DECL ::= CONS_DECL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // DECL ::= TUPLA_DECL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ASIG_SENT ::= id assign EXP semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    print_this("Estas en ASIG_SENT para símbolo");
    if(!error_detectat){
        VariableConstant aux_v1 = taulaSimbols.usarVariableConstant(v1.getValue());
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v2.getTipus() == TipusDades.NULL){
            print_this("Error semántico ASIG_SENT");
            String e = ("Valor no asignado");
            semantic_error(e, v2);
        }else{
            if(aux_v1.getValue() != ""){
                if(!aux_v1.isEsConstant()){
                    if(aux_v1.getTipus() != aux_v2.getTipus()){
                        print_this("Error semántico ASIG_SENT");
                        String e = ("Se está intentando asignar un tipo incorrecto a la variable " + v1.getValue());
                        semantic_error(e, v1);
                    }else{
                        RESULT = aux_v1;
                    }
                }else{
                    print_this("Error semántico ASIG_SENT");
                    String e = ("Se esta intentando asignar un nuevo valor a la constante " + v1.getValue());
                    semantic_error(e, v1);
                }
            }else{
                print_this("Error semántico ASIG_SENT");
                String e = ("La variable " + v1.getValue() + " no ha sido declarada");
                semantic_error(e, v1);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASIG_SENT",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ASIG_SENT ::= TUPLA_ACCESS assign EXP semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    print_this("Estas en ASIG_SENT para tupla");
    if(!error_detectat){
        Tupla aux_v1 = (Tupla) v1;
        Simbol aux_v2 = (Simbol) v2;
        print_this("Asignando valor a Tupla: "+ aux_v1.getValue());
        if(aux_v2.getTipus() == TipusDades.NULL){
            print_this("Error semántico ASIG_SENT");
            String e = ("Valor no asignado");
            semantic_error(e, v2);
        }else{
            if(aux_v1.getTipus() != aux_v2.getTipus()){
                print_this("Error semántico ASIG_SENT");
                String e = ("A la tupla " + aux_v1.getValue() + " se le esta asignando un tipo incorrecto.");
                semantic_error(e, v1);
            }
            RESULT = v1;
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASIG_SENT",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // IF_SENT ::= if_t lparen EXP rparen colon COS else_t colon COS endif 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		
    print_this("Estas en IF_SENT con else");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico IF_SENT");
            String e = ("Debes asignar una condición al if");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico IF_SENT");
                String e = ("La condición de la sentencia 'if' no es correcta");
                semantic_error(e, v1);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_SENT",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // IF_SENT ::= if_t lparen EXP rparen colon COS endif 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		
    print_this("Estas en IF_SENT sin else");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico IF_SENT");
            String e = ("Debes asignar una condición al if");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico IF_SENT");
                String e = ("La condición de la sentencia 'if' no es correcta");
                semantic_error(e, v1);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_SENT",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // WHILE_SENT ::= while_t lparen EXP rparen colon COS endwhile 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		
    print_this("Estas en WHILE_SENT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico WHILE_SENT");
            String e = ("Debes asignar una condición al bucle");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico WHILE_SENT");
                String e = ("La condición de la sentencia 'while' no es correcta");
                semantic_error(e, v1);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("WHILE_SENT",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // FOR_SENT ::= for_t FORINIT to FORLIMIT colon COS endfor 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		
    print_this("Estas en FOR_SENT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición init de la sentencia 'for' no es correcta");
            semantic_error(e, v1);
        }else if(aux_v2.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición limit de la sentencia 'for' no es correcta");
            semantic_error(e, v2);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR_SENT",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // FORINIT ::= PARAM assign EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en FORINIT");
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() != aux_v2.getTipus()){
            print_this("Error semántico FORINIT");
            String e = ("Estas asignando un tipo incorrecto al parámetro del bucle for");
            semantic_error(e, v2);
        }else{
            RESULT = aux_v1;
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FORINIT",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // FORINIT ::= EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en FORINIT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORINIT");
            String e = ("Inicio del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FORINIT",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // FORLIMIT ::= PARAM 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = v1;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FORLIMIT",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // FORLIMIT ::= EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en FORLIMIT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORLIMIT");
            String e = ("Límite del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FORLIMIT",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // SAL_SENT ::= out lparen OUT_EXP rparen semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
    print_this("Estas en SAL_SENT");
    Simbol aux_v1 = (Simbol) v1;
    if(aux_v1.getTipus() == TipusDades.NULL){
        print_this("Error semántico SAL_SENT");
        String e = ("Salida vacía");
        semantic_error(e, v1);
    }else{
        RESULT = aux_v1;
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SAL_SENT",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // OUT_EXP ::= CRID_SIMB 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en OUT_EXP llamada a símbolo"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OUT_EXP",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // OUT_EXP ::= ARIT_TERM 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en OUT_EXP llamada a término aritmético"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OUT_EXP",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // OUT_EXP ::= LOG_TERM 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en OUT_EXP llamada a término lógico"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OUT_EXP",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // OUT_EXP ::= LIT 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en OUT_EXP llamada a literal"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OUT_EXP",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // CRID_FUNC_SENT ::= id lparen ARGS rparen semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
    print_this("Estas en CRID_FUNC_SENT para argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
        if(aux_v1.getValue() != ""){
            if(aux_v1.mateixosParametres(aux_v2)){
                RESULT = aux_v1;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + v1.getValue() + " no se le estan pasando los parámetros correctos");
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRID_FUNC_SENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // CRID_FUNC_SENT ::= id lparen rparen semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		
    print_this("Estas en CRID_FUNC_SENT sin argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        if(aux_v1.getValue() != ""){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRID_FUNC_SENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // CRID_FUNC ::= id lparen ARGS rparen 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		

    print_this("Estas en CRID_FUNC para argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
        if(aux_v1.getValue() != ""){
            if(aux_v1.mateixosParametres(aux_v2)){
                RESULT = aux_v1;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + v1.getValue() + " no se le estan pasando los parámetros correctos: "+aux_v2.toString());
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRID_FUNC",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // CRID_FUNC ::= id lparen rparen 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
    print_this("Estas en CRID_FUNC sin argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        if(aux_v1.getValue() != ""){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRID_FUNC",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // FUNC_DECL ::= fnct TIPO id lparen PARAM_LIST rparen colon COS FINAL_RTN endfnct 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Simbol v2 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int v3left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int v3right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object v3 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int v4left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v4right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v4 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		

    print_this("Estas en FUNC_DECL con cuerpo");
    if(!error_detectat){
        print_this("Declarando Función: "+ v2.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        ArrayList<VariableConstant> aux_v3 = (ArrayList<VariableConstant>) v3;
        Simbol aux_v4 = (Simbol) v4;
        for(int i = 0; i < aux_v3.size() && !error_detectat; i++){
            print_this(aux_v3.get(i).toString());
        }
        if(!error_detectat){
            if(aux_v4.getTipus() != aux_v1.getTipus()){
                print_this("Error semántico FUNC_DECL");
                String e = ("El valor devuelto no corresponde con el tipo de la función.");
                semantic_error(e, v4);
            }
        }
        if(!error_detectat){
            error_detectat = !taulaSimbols.declararFuncio(new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus()));
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
                semantic_error(e, v2);
            }else{
                print_this("Función '" + v2.getValue() + " de tipo " + aux_v1.getTipus().toString() + " creada con éxito");
                RESULT = new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus());
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_DECL",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // FUNC_DECL ::= fnct TIPO id lparen PARAM_LIST rparen colon FINAL_RTN endfnct 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Simbol v2 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int v3left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int v3right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object v3 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int v4left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v4right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v4 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    print_this("Estas en FUNC_DECL sin cuerpo");
    if(!error_detectat){
        print_this("Declarando Función: "+ v2.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        ArrayList<VariableConstant> aux_v3 = (ArrayList<VariableConstant>) v3;
        Simbol aux_v4 = (Simbol) v4;
        for(int i = 0; i < aux_v3.size() && !error_detectat; i++){
            print_this(aux_v3.get(i).toString());
        }
        if(!error_detectat){
            if(aux_v4.getTipus() != aux_v1.getTipus()){
                print_this("Error semántico FUNC_DECL");
                String e = ("El valor devuelto no corresponde con el tipo de la función.");
                semantic_error(e, v4);
            }
        }
        if(!error_detectat){
            error_detectat = !taulaSimbols.declararFuncio(new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus()));
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
                semantic_error(e, v2);
            }else{
                print_this("Función '" + v2.getValue() + " de tipo " + aux_v1.getTipus().toString() + " creada con éxito");
                RESULT = new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus());
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNC_DECL",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // COS ::= SENT COS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COS",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // COS ::= SENT 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COS",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // FINAL_RTN ::= rtrn lparen EXP rparen semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
    print_this("Estas en FINAL_RTN con cuerpo");
    Simbol aux_v1 = (Simbol) v1;
    if(aux_v1.getTipus() == TipusDades.NULL){
        print_this("Error semántico FINAL_RTN");
        String e = ("No se ha devuelto ningún valor");
        semantic_error(e, v1);
    }else{
        RESULT = aux_v1;
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FINAL_RTN",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // VAR_DECL ::= val id double_colon TIPO assign EXP semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int v3left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v3right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v3 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    print_this("Estas en VAR_DECL");
    if(!error_detectat){
        print_this("Declarando Variable "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        if(aux_v3.getTipus() == TipusDades.NULL){
            print_this("Error semántico VAR_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, v3);
        }else{
            error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), false));
            if(error_detectat){
                print_this("Error semántico VAR_DECL");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Variable '" + v1.getValue() + "' creada con éxito");
                RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), false);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VAR_DECL",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // CONS_DECL ::= con id double_colon TIPO assign EXP semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int v3left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v3right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v3 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    print_this("Estas en CONS_DECL");
    if(!error_detectat){
        print_this("Declarando Constante "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        if(aux_v3.getTipus() == TipusDades.NULL){
            print_this("Error semántico CONS_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, v3);
        }else{
            error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), true));
            if(error_detectat){
                print_this("Error semántico CONS_DECL");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Constante '" + v1.getValue() + "' creada con éxito");
                RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), true);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONS_DECL",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // TUPLA_DECL ::= tuple id assign lbrace TIPO comma TIPO rbrace semicolon 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int v3left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v3right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v3 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
    print_this("Estas en TUPLA_DECL");
    if(!error_detectat){
        print_this("Declarando Tupla: "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        error_detectat = !taulaSimbols.declararTupla(new Tupla(v1.getValue(), aux_v2.getTipus(), aux_v3.getTipus()));
        if(error_detectat){
            print_this("Error semántico TUPLA_DECL");
            String e = ("Ya existe una tupla con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Tupla '" + v1.getValue() + "["+ aux_v2.getTipus().toString() +", "+ aux_v3.getTipus().toString() +"]' creada con éxito");
            RESULT = new Tupla(v1.getValue(), aux_v2.getTipus(), aux_v3.getTipus());
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TUPLA_DECL",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // EXP ::= LOG_TERM 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en EXP termino lógico"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXP",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // EXP ::= ARIT_TERM 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en EXP termino aritmético"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXP",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // EXP ::= CRID_SIMB 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en EXP llamada a símbolo"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXP",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // EXP ::= LIT 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en EXP llamada a literal"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXP",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // EXP ::= ENTR_FUNC 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 print_this("Estas en EXP entrada de sistema"); RESULT = v1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXP",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // LIT ::= ENT_LIT 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en LIT integer");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        //aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar();
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LIT",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // LIT ::= BOL_LIT 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en LIT booleano");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        //aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar();
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LIT",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // ENT_LIT ::= POS_ENT_LIT 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en ENT_LIT positivo");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        //aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar();
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ENT_LIT",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // ENT_LIT ::= minus POS_ENT_LIT 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en ENT_LIT negativo");
    Simbol aux_v1 = (Simbol) v1;

    int t = c3a.novavar();
    c3a.genera("neg", (Integer) aux_v1.getR(), buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ENT_LIT",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // POS_ENT_LIT ::= integer_literal 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Positive integer");
    Simbol aux_v1 = (Simbol) v1;

    int t = c3a.novavar();
    c3a.genera("copy", (Integer) aux_v1.getValue(), buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("POS_ENT_LIT",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // BOL_LIT ::= boolean_literal 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Boolean literal");
    Simbol aux_v1 = (Simbol) v1;
    int val = buid;
    if((String) aux_v1.getValue() == "TRUE" || (String) aux_v1.getValue() == "true"){
        val = -1;
    }else{
        val = 0;
    }

    int t = c3a.novavar();
    c3a.genera("copy", val, buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BOL_LIT",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // TUPLA_ACCESS ::= id lbracket integer_literal rbracket 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Simbol v2 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    print_this("Estas en TUPLA_ACCESS");
    if(!error_detectat){
        print_this("Accediendo a la Tupla: " + v1.getValue() + "(" + v2.getValue() + ")");
        Integer index = (Integer) v2.getValue();
        Tupla aux_tupla = taulaSimbols.usarTupla(v1.getValue());
        if(aux_tupla.getValue() != ""){
            if(index == 0 || index == 1){
                aux_tupla.setTipus(aux_tupla.getTipus(index));
                aux_tupla.setFila(index.getFila());
                aux_tupla.setColumna(index.getColumna());

                int t1 = ((Integer) v2.getValue()) - 0;
                int t2 = t1 * nbytes;
                aux_tupla.setD(t2);

                RESULT = aux_tupla;
            }else{
                print_this("Error semántico TUPLA_ACCESS");
                String e = ("El índice '" + index + "' de la tupla " + v1.getValue() + " no es correcto. Los índices de tupla solo permíten 0 o 1.");
                semantic_error(e, v2);
            }
        }else{
            print_this("Error semántico TUPLA_ACCESS");
            String e = ("La tupla " + v1.getValue() + " no ha sido declarada.");
            semantic_error(e, v1);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TUPLA_ACCESS",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // TIPO ::= integer 
            {
              Object RESULT =null;
		 print_this("Tipo integer"); RESULT = new Simbol("integer", TipusDades.INTEGER, 1);//1 valor per tipus integer 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TIPO",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // TIPO ::= logical 
            {
              Object RESULT =null;
		 print_this("Tipo boolean"); RESULT = new Simbol("logical", TipusDades.BOOLEAN, 2);//2 valor per tipus boolean 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TIPO",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // ARGS ::= EXP ARGS_LIST 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en ARGS");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            RESULT = new ArrayList<Simbol>();
        }else{
            ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
            aux_v2.add(0, aux_v1);
            RESULT = aux_v2;
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARGS",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // ARGS_LIST ::= comma EXP ARGS_LIST 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en ARGS_LIST");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico ARGS_LIST");
            String e = ("Argumento vacío");
            semantic_error(e, v1);
        }else{
            ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
            aux_v2.add(0, aux_v1);
            RESULT = aux_v2;
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARGS_LIST",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // ARGS_LIST ::= 
            {
              Object RESULT =null;
		 print_this("Estas en ARGS_LIST epsilon"); RESULT = new ArrayList<Simbol>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARGS_LIST",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // PARAM_LIST ::= PARAM 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en PARAM_LIST");
    if(!error_detectat){
        RESULT = new ArrayList<VariableConstant>(Arrays.asList((VariableConstant) v1));
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAM_LIST",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // PARAM_LIST ::= PARAM comma PARAM_LIST 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en PARAM_LIST");
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        ArrayList<VariableConstant> aux_v2 = (ArrayList<VariableConstant>) v2;
        aux_v2.add(0, aux_v1);
        RESULT = aux_v2;
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAM_LIST",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // PARAM_LIST ::= 
            {
              Object RESULT =null;
		 print_this("Estas en PARAM_LIST epsilon"); RESULT = new ArrayList<VariableConstant>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAM_LIST",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // PARAM ::= id double_colon TIPO 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en PARAM");
    if(!error_detectat){
        print_this("Declarando Parámetro "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), false));
        if(error_detectat){
            print_this("Error semántico PARAM");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Parámetro '" + v1.getValue() + "' creado con éxito");
            RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), false);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAM",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // LOG_TERM ::= EXP equal EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en LOG_TERM equal");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
                if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                if(aux_v1.getTipus() == aux_v2.getTipus()){
                    print_this(aux_v1.getValue() + " equal " + aux_v2.getValue());

                    int t = c3a.novavar();
                    int e1 = c3a.novaetiqueta();
                    int e2 = c3a.novaetiqueta();
                    c3a.genera("ifNE", aux_v1.getR(), aux_v2.getR(), e1);
                    c3a.genera("copy", 0, buid, t);
                    c3a.genera("goto", buid, buid, e2);
                    c3a.genera("skip", buid, buid, e1);
                    c3a.genera("copy", -1, buid, t);
                    c3a.genera("skip", buid, buid, e2);
                    RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t);
                }else{
                    print_this("Error semántico LOG_TERM");
                    String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
                    semantic_error(e, v1);
                }
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOG_TERM",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // LOG_TERM ::= EXP not_equal EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en LOG_TERM not equal");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                if(aux_v1.getTipus() == aux_v2.getTipus()){
                    print_this(aux_v1.getValue() + " not_equal "+aux_v2.getValue());

                    int t = c3a.novavar();
                    int e1 = c3a.novaetiqueta();
                    int e2 = c3a.novaetiqueta();
                    c3a.genera("ifEQ", aux_v1.getR(), aux_v2.getR(), e1);
                    c3a.genera("copy", 0, buid, t);
                    c3a.genera("goto", buid, buid, e2);
                    c3a.genera("skip", buid, buid, e1);
                    c3a.genera("copy", -1, buid, t);
                    c3a.genera("skip", buid, buid, e2);
                    RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t);
                }else{
                    print_this("Error semántico LOG_TERM");
                    String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
                    semantic_error(e, v1);
                }
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOG_TERM",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // LOG_TERM ::= EXP and EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en LOG_TERM and");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                print_this(aux_v1.getValue() + " and " + aux_v2.getValue());

                int t = c3a.novavar();
                c3a.genera("and", aux_v1.getR(), aux_v2.getR(), t);
                RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOG_TERM",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // LOG_TERM ::= EXP or EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en LOG_TERM or");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                print_this(aux_v1.getValue() + " or " + aux_v2.getValue());

                int t = c3a.novavar();
                c3a.genera("or", aux_v1.getR(), aux_v2.getR(), t);
                RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t);
            }
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOG_TERM",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // ARIT_TERM ::= EXP plus EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en ARIT_TERM");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.INTEGER || aux_v2.getTipus() ==  TipusDades.INTEGER){

            int t = c3a.novavar();
            c3a.genera("add", aux_v1.getR(), aux_v2.getR(), t);
            aux_v1.setR(t);

            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = ("El término aritmético solo puede sumar tipos integer");
            semantic_error(e, aux_v1);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARIT_TERM",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // ARIT_TERM ::= EXP minus EXP 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en ARIT_TERM");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus() || aux_v2.getTipus() ==  TipusDades.NULL){

            int t = c3a.novavar();
            c3a.genera("sub", aux_v1.getR(), aux_v2.getR(), t);
            aux_v1.setR(t);

            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = ("El término aritmético solo puede restar tipos integer");
            semantic_error(e, aux_v1);
        }
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARIT_TERM",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // ENTR_FUNC ::= in lparen TIPO rparen 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    print_this("Estas en ENTR_FUNC");
    Simbol aux_v1 = (Simbol) v1;

    int d0 = c3a.novavar();
    c3a.genera("copy", aux_v1.getValor(), buid, d0);
    int d1 = c3a.novavar();
    c3a.genera("in", d0, buid, d1);

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ENTR_FUNC",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // CRID_SIMB ::= id 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Simbol v1 = (Simbol)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en CRID_SIMB id");
    Simbol aux_v1 = taulaSimbols.usarSimbol(v1.getValue()); //d = consulta(ts, id.id);
    if(aux_v1.getValue() != ""){

        //if d.td = dvar {
        //R.r = d.nv; d.nv té el número de variable
        //} else {
        int t = c3a.novavar();
        c3a.genera("copy", aux_v1.getValor(), buid, t);
        aux_v1.setR(t);
        //}
        aux_v1.setD(-3);

        RESULT = aux_v1;
    }else{
        print_this("Error semántico EXP");
        String e = ("El símbolo llamado no ha sido declarado");
        semantic_error(e, v1);
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRID_SIMB",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // CRID_SIMB ::= CRID_FUNC 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en CRID_SIMB funcion");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar();
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRID_SIMB",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // CRID_SIMB ::= TUPLA_ACCESS 
            {
              Object RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object v1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    print_this("Estas en CRID_SIMB tupla");

    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar();
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRID_SIMB",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
