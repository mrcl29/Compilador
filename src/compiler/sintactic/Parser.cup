package compiler.sintactic;
/**
 * parser.cup
 *
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 *
 * Marc Llobera Villalonga
 */

import java.lang.Exception;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import compiler.sintactic.Symbols.*;
import compiler.c3a.*;

class Parser;

parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/

    TaulaSimbols taulaSimbols = new TaulaSimbols();

    public boolean error_detectat = false;

    public boolean DEBUG = false;
    public void print_this(Object msg){
        if(DEBUG){
            System.out.println(msg);
        }
    }

    GenerarCodi c3a = new GenerarCodi();

    int nbytes = 4;
    String buid = "";

    /**************************************************************
    ************************ GESTIÓ ERRORS ************************
    **************************************************************/

    @Override
    public void syntax_error(Symbol s) {
        report_error("Error sintáctico", s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        report_error("Error sintáctico inrrecuperable", s);
        done_parsing();
    }

    @Override
    public void report_error(String t, Object info) {
        print_this("Reportando error...");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();

            print_error("Error en la linea " + l.getLine() + " y columna " + l.getColumn() + ": " + info.toString() + " --> " + t);
        }else{
            print_error("info no es Symbol en report_error");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal ("+message+")", info);
        done_parsing();
    }

    /**
    * Mètode per mostrar un error semàntic
    **/
    public void semantic_error(String t, Object info){
        if(info instanceof Simbol){
            Simbol token = (Simbol) info;

            print_error("Error semántico en la linea " + token.getFila() + " y columna " + token.getColumna() + " --> " + t);
        }else{
            print_error("info no es Symbol en semantic_error");
        }
        done_parsing();
    }

    /**
    * Mètode per mostrar un error
    **/
    public void print_error(String msg){
        error_detectat = true;
        System.err.println("Error--> " + msg);
        done_parsing();
    }
:}

/* Definición de terminales (tokens) */
terminal Simbol fnct, endfnct, rtrn, val, con, if_t, else_t, endif, while_t, endwhile, for_t, to, endfor, in, out, tuple;
terminal Simbol integer, logical;
terminal Simbol assign, plus, minus, equal, not_equal, and, or;
terminal Simbol lparen, rparen, colon, double_colon, semicolon, comma, lbrace, rbrace, lbracket, rbracket;
terminal Simbol integer_literal;
terminal Simbol boolean_literal;
terminal Simbol id;

/* No terminales */
non terminal S, P, DECL, VAR_DECL, CONS_DECL, TUPLA_DECL, SENT;
non terminal FUNC_DECL, FUNCINIT, PARAM_LIST, PARAM, COS, FINAL_RTN;
non terminal CRID_FUNC, ARGS, ARGS_LIST;
non terminal ASIG_SENT;
non terminal IF_SENT, IF_ELSE, IF_INIT;
non terminal WHILE_SENT, WHILE_REP, M;
non terminal FOR_SENT, FORINIT, FORLIMIT;
non terminal SAL_SENT;
non terminal TIPO, EXP, CRID_SIMB, ARIT_TERM, LOG_TERM, TUPLA_ACCESS, LIT, ENT_LIT, POS_ENT_LIT, BOL_LIT, OUT_EXP, ENTR_FUNC;

/* Precedencia y asociatividad */
precedence left and, or;        // Menor precedencia
precedence left equal, not_equal; // Operadores relacionales === y /=
precedence left plus, minus;      // Operadores aritméticos + y -

/* Símbolo inicial */
start with S;

/* Reglas de gramática */

S ::= P {: c3a.tancar(); c3a.crearEnsamblador(); done_parsing(); :};

P ::= SENT P
    | FUNC_DECL P
    | /* epsilon */;

SENT ::= DECL
       | ASIG_SENT
       | IF_SENT
       | WHILE_SENT
       | FOR_SENT
       | SAL_SENT
       | CRID_FUNC
       ;

DECL ::= VAR_DECL
       | CONS_DECL
       | TUPLA_DECL
       ;

ASIG_SENT ::= id:vid assign EXP:vE semicolon
{:
    print_this("Estas en ASIG_SENT para símbolo");
    if(!error_detectat){
        VariableConstant id = taulaSimbols.usarVariableConstant(vid.getValue());
        Simbol E = (Simbol) vE;
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico ASIG_SENT");
            String e = ("Valor no asignado");
            semantic_error(e, vE);
        }else{
            if(id.getValue() != ""){
                if(!id.isEsConstant()){
                    if(id.getTipus() != E.getTipus()){
                        print_this("Error semántico ASIG_SENT");
                        String e = ("Se está intentando asignar un tipo incorrecto a la variable " + vid.getValue());
                        semantic_error(e, vE);
                    }else{
                        id.setValor(E.getValor());

                        c3a.genera("copy", E.getR(), buid, id.getR()); // copy R.r = E.r

                        RESULT = id;
                    }
                }else{
                    print_this("Error semántico ASIG_SENT");
                    String e = ("Se esta intentando asignar un nuevo valor a la constante " + vid.getValue());
                    semantic_error(e, vid);
                }
            }else{
                print_this("Error semántico ASIG_SENT");
                String e = ("La variable " + vid.getValue() + " no ha sido declarada");
                semantic_error(e, vid);
            }
        }
    }
:}
            | TUPLA_ACCESS:vTUPLA_ACCESS assign EXP:vE semicolon
{:
    print_this("Estas en ASIG_SENT para tupla");
    if(!error_detectat){
        Tupla TUPLA_ACCESS = (Tupla) vTUPLA_ACCESS;
        Simbol E = (Simbol) vE;
        print_this("Asignando valor a Tupla: "+ TUPLA_ACCESS.getValue());
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico ASIG_SENT");
            String e = ("Valor no asignado");
            semantic_error(e, vE);
        }else{
            if(TUPLA_ACCESS.getTipus() != E.getTipus()){
                print_this("Error semántico ASIG_SENT");
                String e = ("A la tupla " + TUPLA_ACCESS.getValue() + " se le esta asignando un tipo incorrecto.");
                semantic_error(e, vTUPLA_ACCESS);
            }else{
                if(TUPLA_ACCESS.getRef() == 0){
                    TUPLA_ACCESS.setVal1(E.getValor());
                }else{
                    TUPLA_ACCESS.setVal2(E.getValor());
                }

                c3a.genera("ind_ass", E.getR(), TUPLA_ACCESS.getD(), TUPLA_ACCESS.getR());

                RESULT = TUPLA_ACCESS;
            }
        }
    }
:}
;

IF_SENT ::= IF_ELSE:vIF_ELSE COS endif //if else
{:
    print_this("Estas en IF_SENT con else");
    if(!error_detectat){
        Simbol IF_ELSE = (Simbol) vIF_ELSE;

        c3a.genera("skip", buid, buid, IF_ELSE.getEtiqueta()); //efi: skip
    }
:}
          | IF_INIT:vIF_INIT COS endif //if
{:
    print_this("Estas en IF_SENT sin else");
    if(!error_detectat){
        Simbol IF_INIT = (Simbol) vIF_INIT;

        c3a.genera("skip", buid, buid, IF_INIT.getEtiqueta()); //efi: skip
    }
:}
;

IF_ELSE ::= IF_INIT:vIF_INIT COS else_t colon
{:
    print_this("Estas en IF_ELSE");
    if(!error_detectat){
        Simbol IF_INIT = (Simbol) vIF_INIT;

        String efi = c3a.novaetiqueta();
        c3a.genera("goto", buid, buid, efi);                  //goto efi
        c3a.genera("skip", buid, buid, IF_INIT.getEtiqueta()); //e: skip
        IF_INIT.setEtiqueta(efi);

        RESULT = IF_INIT;
    }
:}
;

IF_INIT ::= if_t lparen EXP:vE rparen colon
{:
    print_this("Estas en IF_INIT");
    if(!error_detectat){
        Simbol E = (Simbol) vE;
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico IF_INIT");
            String e = ("Debes asignar una condición al if");
            semantic_error(e, vE);
        }else{
            if(E.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico IF_INIT");
                String e = ("La condición de la sentencia 'if' no es correcta");
                semantic_error(e, vE);
            }else{

                String e = c3a.novaetiqueta();
                c3a.genera("if_EQ", E.getR(), "0", e); // if E.r=0 goto e
                E.setEtiqueta(e);

                RESULT = E;
            }
        }
    }
:}
;

WHILE_SENT ::= WHILE_REP:vWHILE_REP COS endwhile
{:
    print_this("Estas en WHILE_SENT");
    if(!error_detectat){
        Simbol WHILE_REP = (Simbol) vWHILE_REP;

        c3a.genera("goto", buid, buid, WHILE_REP.getEtiqueta()); // goto WHILE_REP.ei
        c3a.genera("skip", buid, buid, WHILE_REP.getEtiquetafi()); // WHILE_REP.efi: skip
    }
:}
;

WHILE_REP ::= while_t lparen M:vM EXP:vE rparen colon
{:
    print_this("Estas en WHILE_REP");
    if(!error_detectat){
        Simbol E = (Simbol) vE;
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico WHILE_SENT");
            String e = ("Debes asignar una condición al bucle");
            semantic_error(e, vE);
        }else{
            if(E.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico WHILE_SENT");
                String e = ("La condición de la sentencia 'while' no es correcta");
                semantic_error(e, vE);
            }else{
                Simbol WHILE_REP = new Simbol();
                Simbol M = (Simbol) vM;

                String efi = c3a.novaetiqueta();
                c3a.genera("if_EQ", E.getR(), "0", efi); // if E.r = 0 goto efi
                WHILE_REP.setEtiquetafi(efi);
                WHILE_REP.setEtiqueta(M.getEtiqueta());

                RESULT = WHILE_REP;
            }
        }
    }
:}
;

M ::= /* epsilon */
{:
    Simbol M = new Simbol();

    String ei = c3a.novaetiqueta();
    c3a.genera("skip", buid, buid, ei); // ei: skip
    M.setEtiqueta(ei);

    RESULT = M;
:}
;

FOR_SENT ::= for_t FORINIT:v1 to FORLIMIT:v2 colon COS endfor
{:
    print_this("Estas en FOR_SENT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición init de la sentencia 'for' no es correcta");
            semantic_error(e, v1);
        }else if(aux_v2.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición limit de la sentencia 'for' no es correcta");
            semantic_error(e, v2);
        }
    }
:}
;

FORINIT ::= PARAM:v1 assign EXP:v2
{:
    print_this("Estas en FORINIT");
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() != aux_v2.getTipus()){
            print_this("Error semántico FORINIT");
            String e = ("Estas asignando un tipo incorrecto al parámetro del bucle for");
            semantic_error(e, v2);
        }else{
            RESULT = aux_v1;
        }
    }
:}
         | EXP:v1
{:
    print_this("Estas en FORINIT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORINIT");
            String e = ("Inicio del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:}
;

FORLIMIT ::= PARAM:v1 {: RESULT = v1;:}
           | EXP:v1
{:
    print_this("Estas en FORLIMIT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORLIMIT");
            String e = ("Límite del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:}
;

SAL_SENT ::= out lparen OUT_EXP:vOUT rparen semicolon
{:
    print_this("Estas en SAL_SENT");
    Simbol OUT = (Simbol) vOUT;
    if(OUT.getTipus() == TipusDades.NULL){
        print_this("Error semántico SAL_SENT");
        String e = ("Salida vacía");
        semantic_error(e, vOUT);
    }else{
        String i;
        if(OUT.getTipus() == TipusDades.INTEGER){
            i = "1";
        }else{
            i = "2";
        }

        String d0 = c3a.novavar(OUT);
        c3a.genera("copy", i, buid, d0);
        String d1 = c3a.novavar(OUT);
        c3a.genera("copy", OUT.getR(), buid, d1);
        c3a.genera("out", d0, buid, d1);
    }
:}
;

OUT_EXP ::= CRID_SIMB:v1 {: print_this("Estas en OUT_EXP llamada a símbolo"); RESULT = v1; :}
          | ARIT_TERM:v1 {: print_this("Estas en OUT_EXP llamada a término aritmético"); RESULT = v1; :}
          | LOG_TERM:v1  {: print_this("Estas en OUT_EXP llamada a término lógico"); RESULT = v1; :}
          | LIT:v1       {: print_this("Estas en OUT_EXP llamada a literal"); RESULT = v1; :}
          ;

CRID_FUNC ::= id:vid lparen ARGS:vARGS rparen
{:
    print_this("Estas en CRID_FUNC para argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ vid.getValue());
        Funcio id = taulaSimbols.usarFuncio(vid.getValue());
        ArrayList<Simbol> ARGS = (ArrayList<Simbol>) vARGS;
        if(id.getValue() != ""){
            if(id.mateixosParametres(ARGS)){

                c3a.genera("call", buid, buid, id.getR());

                RESULT = id;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + vid.getValue() + " no se le estan pasando los parámetros correctos: "+ARGS.toString());
                semantic_error(e, vid);
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + vid.getValue() + " no ha sido creada");
            semantic_error(e, vid);
        }
    }
:}
            | id:vid lparen rparen
{:
    print_this("Estas en CRID_FUNC sin argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ vid.getValue());
        Funcio id = taulaSimbols.usarFuncio(vid.getValue());
        ArrayList<Simbol> aux_v2 = new ArrayList<Simbol>();
        if(id.getValue() != ""){
            if(id.mateixosParametres(aux_v2)){

                c3a.genera("call", buid, buid, id.getR());

                RESULT = id;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + vid.getValue() + " no se le estan pasando los parámetros correctos: "+aux_v2.toString());
                semantic_error(e, vid);
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + vid.getValue() + " no ha sido creada");
            semantic_error(e, vid);
        }
    }
:}
;

ARGS ::= EXP:vE ARGS_LIST:vARGS_LIST
{:
    print_this("Estas en ARGS");
    if(!error_detectat){
        Simbol E = (Simbol) vE;
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico ARGS");
            String e = ("Argumento vacío");
            semantic_error(e, vE);
        }else{
            ArrayList<Simbol> ARGS_LIST = (ArrayList<Simbol>) vARGS_LIST;
            ARGS_LIST.add(0, E);

            c3a.genera("param_s", buid, buid, E.getR());

            RESULT = ARGS_LIST;
        }
    }
:}
;

ARGS_LIST ::= comma EXP:vE ARGS_LIST:vARGS_LIST
{:
    print_this("Estas en ARGS_LIST");
    if(!error_detectat){
        Simbol E = (Simbol) vE;
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico ARGS_LIST");
            String e = ("Argumento vacío");
            semantic_error(e, vE);
        }else{
            ArrayList<Simbol> ARGS_LIST = (ArrayList<Simbol>) vARGS_LIST;
            ARGS_LIST.add(0, E);

            c3a.genera("param_s", buid, buid, E.getR());

            RESULT = ARGS_LIST;
        }
    }
:}
            | /* epsilon */ {: print_this("Estas en ARGS_LIST epsilon"); RESULT = new ArrayList<Simbol>(); :}
;

FUNC_DECL ::= FUNCINIT:vFUNCINIT COS FINAL_RTN:vRTN endfnct
{:
    print_this("Estas en FUNC_DECL con cuerpo");
    if(!error_detectat){
        Simbol FUNCINIT = (Simbol) vFUNCINIT;
        Simbol RTN = (Simbol) vRTN;
        if(RTN.getTipus() != FUNCINIT.getTipus()){
            print_this("Error semántico FUNC_DECL");
            String e = ("El valor devuelto no corresponde con el tipo de la función.");
            semantic_error(e, vRTN);
        }else{

            c3a.genera("rtn", buid, buid, FUNCINIT.getR());
        }
    }
:}
            | FUNCINIT:vFUNCINIT FINAL_RTN:vRTN endfnct
{:
    print_this("Estas en FUNC_DECL sin cuerpo");
    if(!error_detectat){
        Simbol FUNCINIT = (Simbol) vFUNCINIT;
        Simbol RTN = (Simbol) vRTN;
        if(RTN.getTipus() != FUNCINIT.getTipus()){
            print_this("Error semántico FUNC_DECL");
            String e = ("El valor devuelto no corresponde con el tipo de la función.");
            semantic_error(e, vRTN);
        }else{

            c3a.genera("rtn", buid, buid, FUNCINIT.getR());
        }
    }
:}
;

FUNCINIT ::= fnct TIPO:vTIPO id:vid lparen PARAM_LIST:vPARAM_LIST rparen colon
{:
    print_this("Estas en FUNCINIT con cuerpo");
    if(!error_detectat){
        print_this("Declarando Función: "+ vid.getValue());
        Simbol TIPO = (Simbol) vTIPO;
        Simbol id = (Simbol) vid;
        ArrayList<VariableConstant> PARAM_LIST = (ArrayList<VariableConstant>) vPARAM_LIST;

        Funcio funcio = new Funcio(id.getValue(), PARAM_LIST, TIPO.getTipus());
        error_detectat = !taulaSimbols.declararFuncio(funcio);
        if(error_detectat){
            print_this("Error semántico FUNCINIT");
            String e = ("Ya existe una función con el nombre '" + vid.getValue() + "'");
            semantic_error(e, vid);
        }else{
            print_this("Función '" + id.getValue() + " de tipo " + TIPO.getTipus().toString() + " creada con éxito");

            String e = c3a.novaetiqueta();
            funcio.setEtiqueta(e);
            String np = c3a.nouproc(funcio);
            c3a.genera("skip", buid, buid, e);
            c3a.genera("pmb", buid, buid, np);
            funcio.setR(np);

            RESULT = funcio;
        }
    }
:}
;

PARAM_LIST ::= PARAM:v1
{:
    print_this("Estas en PARAM_LIST");
    if(!error_detectat){
        RESULT = new ArrayList<VariableConstant>(Arrays.asList((VariableConstant) v1));
    }
:}
             | PARAM:v1 comma PARAM_LIST:v2
{:
    print_this("Estas en PARAM_LIST");
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        ArrayList<VariableConstant> aux_v2 = (ArrayList<VariableConstant>) v2;
        aux_v2.add(0, aux_v1);
        RESULT = aux_v2;
    }
:}
             | /* epsilon */ {: print_this("Estas en PARAM_LIST epsilon"); RESULT = new ArrayList<VariableConstant>(); :}
             ;

PARAM ::= id:v1 double_colon TIPO:v2
{:
    print_this("Estas en PARAM");
    if(!error_detectat){
        print_this("Declarando Parámetro "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), false));
        if(error_detectat){
            print_this("Error semántico PARAM");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Parámetro '" + v1.getValue() + "' creado con éxito");
            RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), false);
        }
    }
:}
;

COS ::= SENT COS
      | SENT
      ;

FINAL_RTN ::= rtrn lparen EXP:v1 rparen semicolon
{:
    print_this("Estas en FINAL_RTN con cuerpo");
    Simbol aux_v1 = (Simbol) v1;
    if(aux_v1.getTipus() == TipusDades.NULL){
        print_this("Error semántico FINAL_RTN");
        String e = ("No se ha devuelto ningún valor");
        semantic_error(e, v1);
    }else{
        RESULT = aux_v1;
    }
:};

VAR_DECL ::= val id:vid double_colon TIPO:vTIPO assign EXP:vE semicolon
{:
    print_this("Estas en VAR_DECL");
    if(!error_detectat){
        print_this("Declarando Variable "+ vid.getValue());
        Simbol id = (Simbol) vid;
        Simbol TIPO = (Simbol) vTIPO;
        Simbol E = (Simbol) vE;
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico VAR_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, vE);
        }else{
            if(E.getTipus() != TIPO.getTipus()){
                print_this("Error semántico VAR_DECL");
                String e = ("A la variable " + id.getValue() + " de tipo " + TIPO.getTipus() + " no se le esta asignando un valor del tipo correcto: " + E.getTipus());
                semantic_error(e, vE);
            }else{
                VariableConstant varcon = new VariableConstant(id.getValue(), TIPO.getTipus(), false);
                error_detectat = !taulaSimbols.declararVariableConstant(varcon);
                if(error_detectat){
                    print_this("Error semántico VAR_DECL");
                    String e = ("Ya existe una variable o constante con el nombre '" + varcon.getValue() + "'");
                    semantic_error(e, vid);
                }else{
                    print_this("Variable '" + varcon.getValue() + "' de tipo '" + varcon.getTipus() + "' creada con éxito");
                    varcon.setValor(E.getValor());

                    String t_id = c3a.novavar(varcon);
                    c3a.genera("copy", E.getR(), buid, t_id); // id.r = E.r

                    varcon.setR(t_id);
                    RESULT = varcon;
                }
            }
        }
    }
:}
;

CONS_DECL ::= con id:vid double_colon TIPO:vTIPO assign EXP:vE semicolon
{:
    print_this("Estas en CONS_DECL");
    if(!error_detectat){
        print_this("Declarando Variable "+ vid.getValue());
        Simbol id = (Simbol) vid;
        Simbol TIPO = (Simbol) vTIPO;
        Simbol E = (Simbol) vE;
        if(E.getTipus() == TipusDades.NULL){
            print_this("Error semántico CONS_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, vE);
        }else{
            if(E.getTipus() != TIPO.getTipus()){
                print_this("Error semántico VAR_DECL");
                String e = ("A la constante " + id.getValue() + " de tipo " + TIPO.getTipus() + " no se le esta asignando un valor del tipo correcto: " + E.getTipus());
                semantic_error(e, vE);
            }else{
                VariableConstant varcon = new VariableConstant(id.getValue(), TIPO.getTipus(), true);
                error_detectat = !taulaSimbols.declararVariableConstant(varcon);
                if(error_detectat){
                    print_this("Error semántico VAR_DECL");
                    String e = ("Ya existe una variable o constante con el nombre '" + varcon.getValue() + "'");
                    semantic_error(e, vid);
                }else{
                    print_this("Constante '" + varcon.getValue() + "' creada con éxito");
                    varcon.setValor(E.getValor());

                    String t_id = c3a.novavar(varcon);
                    c3a.genera("copy", E.getR(), buid, t_id); // id.r = E.r

                    varcon.setR(t_id);
                    RESULT = varcon;
                }
            }
        }
    }
:}
;

TUPLA_DECL ::= tuple id:vid assign lbrace TIPO:vTIPO1 comma TIPO:vTIPO2 rbrace semicolon
{:
    print_this("Estas en TUPLA_DECL");
    if(!error_detectat){
        print_this("Declarando Tupla: "+ vid.getValue());
        Simbol id = (Simbol) vid;
        Simbol TIPO1 = (Simbol) vTIPO1;
        Simbol TIPO2 = (Simbol) vTIPO2;
        Tupla tupla = new Tupla(id.getValue(), TIPO1.getTipus(), TIPO2.getTipus());
        error_detectat = !taulaSimbols.declararTupla(tupla);
        if(error_detectat){
            print_this("Error semántico TUPLA_DECL");
            String e = ("Ya existe una tupla con el nombre '" + id.getValue() + "'");
            semantic_error(e, vid);
        }else{
            print_this("Tupla '" + id.getValue() + "["+ TIPO1.getTipus().toString() +", "+ TIPO2.getTipus().toString() +"]' creada con éxito");

            String t1 = c3a.novavar(tupla);
            tupla.setD("0");
            String t2 = c3a.novavar(tupla);
            tupla.setR(t1);

            RESULT = tupla;
        }
    }
:}
;

EXP ::= LOG_TERM:v1     {: print_this("Estas en EXP termino lógico"); RESULT = v1; :}
      | ARIT_TERM:v1    {: print_this("Estas en EXP termino aritmético"); RESULT = v1; :}
      | CRID_SIMB:v1    {: print_this("Estas en EXP llamada a símbolo"); RESULT = v1; :}
      | LIT:v1          {: print_this("Estas en EXP llamada a literal"); RESULT = v1; :}
      | ENTR_FUNC:v1    {: print_this("Estas en EXP entrada de sistema"); RESULT = v1; :}
      ;

LIT ::= ENT_LIT:v1 {: print_this("Estas en LIT integer"); RESULT = v1; :}
      | BOL_LIT:v1 {: print_this("Estas en LIT booleano"); RESULT = v1; :}
      ;

ENT_LIT ::= POS_ENT_LIT:v1 {: print_this("Estas en ENT_LIT positivo"); RESULT = v1; :}
          | minus POS_ENT_LIT:v1
{:
    print_this("Estas en ENT_LIT negativo");
    Simbol aux_v1 = (Simbol) v1;
    aux_v1.setValor(-1*aux_v1.getValor());

    String t = c3a.novavar(aux_v1);
    c3a.genera("neg", aux_v1.getR(), buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;
:}
;

POS_ENT_LIT ::= integer_literal:v1
{:
    print_this("Positive integer");
    Simbol aux_v1 = (Simbol) v1;
    aux_v1.setValor((Integer) aux_v1.getValue());
    aux_v1.setValue("integer_literal");

    String t = c3a.novavar(aux_v1);
    c3a.genera("copy", String.valueOf(aux_v1.getValor()), buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;
:}
;

BOL_LIT ::= boolean_literal:v1
{:
    print_this("Boolean literal");
    Simbol aux_v1 = (Simbol) v1;
    if((String) aux_v1.getValue() == "TRUE" || (String) aux_v1.getValue() == "true"){
        aux_v1.setValor(-1);
    }else{
        aux_v1.setValor(0);
    }
    aux_v1.setValue("boolean_literal");

    String t = c3a.novavar(aux_v1);
    c3a.genera("copy", String.valueOf(aux_v1.getValor()), buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;
:}
;

TUPLA_ACCESS ::= id:vid lbracket integer_literal:vindex rbracket
{:
    print_this("Estas en TUPLA_ACCESS");
    if(!error_detectat){
        print_this("Accediendo a la Tupla: " + vid.getValue() + "(" + vindex.getValue() + ")");
        Simbol id = (Simbol) vid;
        Simbol index = (Simbol) vindex;
        index.setValor((Integer) index.getValue());
        index.setValue("integer_literal");
        Tupla TUPLA = taulaSimbols.usarTupla(id.getValue());
        if(TUPLA.getValue() != ""){
            if(index.getValor() == 0 || index.getValor() == 1){
                TUPLA.setRef(index.getValor());
                TUPLA.setValor(TUPLA.getVal(TUPLA.getRef()));
                TUPLA.setTipus(TUPLA.getTipus(index.getValor()));
                TUPLA.setD(String.valueOf(index.getValor()));

                String t1 = c3a.novavar(new Simbol("t1", index.getTipus(), (Integer) index.getValue()));
                c3a.genera("copy", index.getValue().toString(), buid, t1);
                String t2 = c3a.novavar(new Simbol("t2", (((Integer) index.getValue()) * nbytes)));
                c3a.genera("prod", t1, String.valueOf(nbytes), t2);
                TUPLA.setD(t2);

                RESULT = TUPLA;
            }else{
                print_this("Error semántico TUPLA_ACCESS");
                String e = ("El índice '" + index + "' de la tupla " + vid.getValue() + " no es correcto. Los índices de tupla solo permíten 0 o 1.");
                semantic_error(e, vindex);
            }
        }else{
            print_this("Error semántico TUPLA_ACCESS");
            String e = ("La tupla " + vid.getValue() + " no ha sido declarada.");
            semantic_error(e, vid);
        }
    }
:}
;

TIPO ::= integer {: print_this("Tipo integer"); RESULT = new Simbol("integer", TipusDades.INTEGER, 1);//1 valor per tipus integer :}
       | logical {: print_this("Tipo boolean"); RESULT = new Simbol("logical", TipusDades.BOOLEAN, 2);//2 valor per tipus boolean :}
       ;

LOG_TERM ::= EXP:vE1 equal EXP:vE2
{:
    print_this("Estas en LOG_TERM equal");
    if(!error_detectat){
        Simbol E1 = (Simbol) vE1;
        E1 = E1.clone();
        Simbol E2 = (Simbol) vE2;
        if(E1.getTipus() == TipusDades.NULL || E2.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            if (E1.getTipus() == TipusDades.NULL){
                semantic_error(e, vE1);
            }else{
                semantic_error(e, vE2);
            }
        }else{
            if(E1.getTipus() != E2.getTipus()){
                print_this("Error semántico LOG_TERM");
                String e = ("No se pueden comapar valores de diferente tipo");
                semantic_error(e, vE1);
            }else{
                print_this(E1.getValue() + " not_equal "+E2.getValue());

                int val = -3;
                if(E1.getValor() == E2.getValor()){
                    val = -1;
                }else{
                    val = 0;
                }
                E1.setTipus(TipusDades.BOOLEAN);
                E1.setValor(val);

                String t = c3a.novavar(E1);
                String e1 = c3a.novaetiqueta();
                String e2 = c3a.novaetiqueta();
                c3a.genera("if_EQ", E1.getR(), E2.getR(), e1);
                c3a.genera("copy", "0", buid, t);
                c3a.genera("goto", buid, buid, e2);
                c3a.genera("skip", buid, buid, e1);
                c3a.genera("copy", "-1", buid, t);
                c3a.genera("skip", buid, buid, e2);
                E1.setR(t);

                RESULT = E1;
            }
        }
    }
:}
           | EXP:vE1 not_equal EXP:vE2
{:
    print_this("Estas en LOG_TERM not equal");
    if(!error_detectat){
        Simbol E1 = (Simbol) vE1;
        E1 = E1.clone();
        Simbol E2 = (Simbol) vE2;
        if(E1.getTipus() == TipusDades.NULL || E2.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            if (E1.getTipus() == TipusDades.NULL){
                semantic_error(e, vE1);
            }else{
                semantic_error(e, vE2);
            }
        }else{
            if(E1.getTipus() != E2.getTipus()){
                print_this("Error semántico LOG_TERM");
                String e = ("No se pueden comapar valores de diferente tipo");
                semantic_error(e, vE1);
            }else{
                print_this(E1.getValue() + " not_equal "+E2.getValue());

                int val = -3;
                if(E1.getValor() != E2.getValor()){
                    val = -1;
                }else{
                    val = 0;
                }
                E1.setTipus(TipusDades.BOOLEAN);
                E1.setValor(val);

                String t = c3a.novavar(E1);
                String e1 = c3a.novaetiqueta();
                String e2 = c3a.novaetiqueta();
                c3a.genera("if_NE", E1.getR(), E2.getR(), e1);
                c3a.genera("copy", "0", buid, t);
                c3a.genera("goto", buid, buid, e2);
                c3a.genera("skip", buid, buid, e1);
                c3a.genera("copy", "-1", buid, t);
                c3a.genera("skip", buid, buid, e2);
                E1.setR(t);

                RESULT = E1;
            }
        }
    }
:}
           | EXP:vE1 and EXP:vE2
{:
    print_this("Estas en LOG_TERM and");
    if(!error_detectat){
        Simbol E1 = (Simbol) vE1;
        E1 = E1.clone();
        Simbol E2 = (Simbol) vE2;
        if(E1.getTipus() != TipusDades.BOOLEAN || E2.getTipus() != TipusDades.BOOLEAN){
            print_this("Error semántico LOG_TERM");
            String e = ("En los términos lógicos solo se permiten valores booleanos");
            if (E1.getTipus() != TipusDades.BOOLEAN){
                semantic_error(e, vE1);
            }else{
                semantic_error(e, vE2);
            }
        }else{
            print_this(E1.getValue() + " and " + E2.getValue());

            int val = (E1.getValor() == 0 ? 0 : (E1.getValor() == 0 ? 0 : -1)); //Si E1 false entonces false, sino si E2 false entonces false, sino true
            E1.setValor(val);

            String t1 = c3a.novavar(E1);
            String t2 = c3a.novavar(E1);
            String t3 = c3a.novavar(E2);
            String e1 = c3a.novaetiqueta();
            String e2 = c3a.novaetiqueta();
            String e3 = c3a.novaetiqueta();
            c3a.genera("copy", E1.getR(), buid, t1);
            c3a.genera("if_EQ", t1, "-1", e1);
            c3a.genera("copy", "0", buid, t2);
            c3a.genera("goto", buid, buid, e2);
            c3a.genera("skip", buid, buid, e1);
            c3a.genera("copy", E2.getR(), buid, t3);
            c3a.genera("if_EQ", t3, "-1", e3);
            c3a.genera("copy", "0", buid, t2);
            c3a.genera("goto", buid, buid, e2);
            c3a.genera("skip", buid, buid, e3);
            c3a.genera("copy", "-1", buid, t2);
            c3a.genera("skip", buid, buid, e2);
            E1.setR(t2);

            RESULT = E1;
        }
    }
:}
           | EXP:vE1 or EXP:vE2
{:
    print_this("Estas en LOG_TERM or");
    if(!error_detectat){
        Simbol E1 = (Simbol) vE1;
        E1 = E1.clone();
        Simbol E2 = (Simbol) vE2;
        if(E1.getTipus() != TipusDades.BOOLEAN || E2.getTipus() != TipusDades.BOOLEAN){
            print_this("Error semántico LOG_TERM");
            String e = ("En los términos lógicos solo se permiten valores booleanos");
            if (E1.getTipus() != TipusDades.BOOLEAN){
                semantic_error(e, vE1);
            }else{
                semantic_error(e, vE2);
            }
        }else{
            print_this(E1.getValue() + " or " + E2.getValue());
            int val = (E1.getValor() == -1 ? -1 : (E1.getValor() == -1 ? -1 : 0)); //Si E1 true entonces true, sino si E2 true entonces true, sino false
            E1.setValor(val);

            String t1 = c3a.novavar(E1);
            String t2 = c3a.novavar(E1);
            String t3 = c3a.novavar(E2);
            String e1 = c3a.novaetiqueta();
            String e2 = c3a.novaetiqueta();
            String e3 = c3a.novaetiqueta();
            c3a.genera("copy", E1.getR(), buid, t1);
            c3a.genera("if_EQ", t1, "0", e1);
            c3a.genera("copy", "-1", buid, t2);
            c3a.genera("goto", buid, buid, e2);
            c3a.genera("skip", buid, buid, e1);
            c3a.genera("copy", E2.getR(), buid, t3);
            c3a.genera("if_EQ", t3, "0", e3);
            c3a.genera("copy", "-1", buid, t2);
            c3a.genera("goto", buid, buid, e2);
            c3a.genera("skip", buid, buid, e3);
            c3a.genera("copy", "0", buid, t2);
            c3a.genera("skip", buid, buid, e2);
            E1.setR(t2);

            RESULT = E1;
        }
    }
:}
;

ARIT_TERM ::= EXP:vE1 plus EXP:vE2
{:
    print_this("Estas en ARIT_TERM +");
    if(!error_detectat){
        Simbol E1 = (Simbol) vE1;
        E1 = E1.clone();
        Simbol E2 = (Simbol) vE2;
        if(E1.getTipus() == E2.getTipus() && E1.getTipus() ==  TipusDades.INTEGER){
            E1.setValor(E1.getValor()+E2.getValor());

            String t = c3a.novavar(E1);
            c3a.genera("add", E1.getR(), E2.getR(), t);
            E1.setR(t);

            RESULT = E1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = ("El término aritmético solo puede sumar tipos integer: "+E1.getTipus().toString()+" + " + E2.getTipus().toString());
            if (E1.getTipus() != TipusDades.INTEGER){
                semantic_error(e, vE1);
            }else{
                semantic_error(e, vE2);
            }
        }
    }
:}
           | EXP:vE1 minus EXP:vE2
{:
    print_this("Estas en ARIT_TERM -");
    if(!error_detectat){
        Simbol E1 = (Simbol) vE1;
        E1 = E1.clone();
        Simbol E2 = (Simbol) vE2;
        if(E1.getTipus() == E2.getTipus() && E1.getTipus() ==  TipusDades.INTEGER){
            E1.setValor(E1.getValor()-E2.getValor());

            String t = c3a.novavar(E1);
            c3a.genera("sub", E1.getR(), E2.getR(), t);
            E1.setR(t);

            RESULT = E1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = ("El término aritmético solo puede restar tipos integer");
            if (E1.getTipus() != TipusDades.INTEGER){
                semantic_error(e, vE1);
            }else{
                semantic_error(e, vE2);
            }
        }
    }
:}
;

ENTR_FUNC ::= in lparen TIPO:vTIPO rparen
{:
    print_this("Estas en ENTR_FUNC");
    Simbol TIPO = (Simbol) vTIPO;
    TIPO = TIPO.clone();

    String d0 = c3a.novavar(TIPO);
    c3a.genera("copy", String.valueOf(TIPO.getValor()), buid, d0);
    String d1 = c3a.novavar(new Simbol());
    c3a.genera("in", d0, buid, d1);
    TIPO.setR(d1);

    RESULT = TIPO;
:};

CRID_SIMB ::= id:vid
{:
    print_this("Estas en CRID_SIMB id");
    VariableConstant id = taulaSimbols.usarVariableConstant(vid.getValue()); //d = consulta(ts, id.id);
    if(id.getValue() != ""){
        print_this("Se ha obtenido la variable o constante '" + id.getValue() + "' de tipo '" + id.getTipus() + "'");
        RESULT = id;
    }else{
        print_this("Error semántico EXP");
        String e = ("El símbolo llamado no ha sido declarado");
        semantic_error(e, vid);
    }
:}
            | CRID_FUNC:vCRID_FUNC       {: print_this("Estas en CRID_SIMB funcion"); RESULT = vCRID_FUNC; :}
            | TUPLA_ACCESS:vTUPLA_ACCESS
{:
    print_this("Estas en CRID_SIMB tupla");
    Simbol TUPLA_ACCESS = (Simbol) vTUPLA_ACCESS;
    TUPLA_ACCESS = TUPLA_ACCESS.clone();

    String t = c3a.novavar(TUPLA_ACCESS);
    c3a.genera("idx_val", TUPLA_ACCESS.getR(), TUPLA_ACCESS.getD(), t); // idx_val R.r R.d t
    TUPLA_ACCESS.setR(t);
    TUPLA_ACCESS.setD("");

    RESULT = TUPLA_ACCESS;
:}
;
