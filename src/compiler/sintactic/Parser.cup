package compiler.sintactic;
/**
 * parser.cup
 *
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 *
 * Marc Llobera Villalonga
 */

import java.lang.Exception;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import compiler.sintactic.Symbols.*;

class Parser;

parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/

    TaulaSimbols taulaSimbols = new TaulaSimbols();

    public boolean error_detectat = false;

    public boolean DEBUG = true;
    public void print_this(Object msg){
        if(DEBUG){
            System.out.println(msg);
        }
    }

    /**************************************************************
    ************************ GESTIÓ ERRORS ************************
    **************************************************************/

    @Override
    public void syntax_error(Symbol s) {
        report_error("Error sintáctico", s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        report_error("Error sintáctico inrrecuperable", s);
        done_parsing();
    }

    @Override
    public void report_error(String t, Object info) {
        print_this("Reportando error...");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();

            print_error("Error en la linea " + l.getLine() + " y columna " + l.getColumn() + ": " + info.toString() + " --> " + t);
        }else{
            print_error("info no es Symbol en report_error");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal ("+message+")", info);
        done_parsing();
    }

    /**
    * Mètode per mostrar un error semàntic
    **/
    public void semantic_error(String t, Object info){
        print_this("Imprimiendo error semántico...");
        if(info instanceof Simbol){
            Simbol token = (Simbol) info;

            print_error("Error semántico en la linea " + token.getFila() + " y columna " + token.getColumna() + " --> " + t);
        }else{
            print_error("info no es Symbol en semantic_error");
        }
        done_parsing();
    }

    /**
    * Mètode per mostrar un error
    **/
    public void print_error(String msg){
        error_detectat = true;
        System.err.println("Error--> " + msg);
        done_parsing();
    }
:}

/* Definición de terminales (tokens) */
terminal Simbol fnct, endfnct, rtrn, val, con, if_t, else_t, endif, while_t, endwhile, for_t, to, endfor, in, out, tuple;
terminal Simbol integer, logical;
terminal Simbol assign, plus, minus, equal, not_equal, and, or;
terminal Simbol lparen, rparen, colon, double_colon, semicolon, comma, lbrace, rbrace, lbracket, rbracket;
terminal Simbol integer_literal;
terminal Simbol boolean_literal;
terminal Simbol id;

/* No terminales */
non terminal S, P, BODY, DECL, VAR_DECL, CONS_DECL, TUPLA_DECL, FUNC_DECL, PARAM_LIST, PARAM, COS, FINAL_RTN, SENT;
non terminal ASIG_SENT, IF_SENT, WHILE_SENT, FOR_SENT, FORINIT, FORLIMIT, TUPLA_ASSIGN, ENTR_SENT, SAL_SENT, CRID_FUNC, ARGS, ARGS_LIST;
non terminal TIPO, EXP, ARIT_TERM, ARIT_FACTOR, ARIT_TERM_REST, LOG_TERM, TUPLA_ACCESS, LIT, POS_ENT_LIT, NEG_ENT_LIT, BOL_LIT, OUT_EXP, ENTR_FUNC, SAL_FUNC;

/* Precedencia y asociatividad */
precedence left and, or;        // Menor precedencia
precedence left equal, not_equal; // Operadores relacionales === y /=
precedence left plus, minus;      // Operadores aritméticos + y -

/* Símbolo inicial */
start with S;

/* Reglas de gramática */

S ::= P ;

P ::= BODY;

BODY ::= SENT BODY
      | SENT
      | FUNC_DECL BODY
      | FUNC_DECL
      ;

COS ::= SENT COS
      | SENT
      ;

SENT ::= DECL
       | ASIG_SENT
       | IF_SENT
       | WHILE_SENT
       | FOR_SENT
       | TUPLA_ASSIGN
       | ENTR_SENT
       | SAL_SENT
       | CRID_FUNC
       ;

DECL ::= VAR_DECL
       | CONS_DECL
       | TUPLA_DECL
       ;

ASIG_SENT ::= id:v1 assign EXP:v2 semicolon
{:
    if(!error_detectat){
        VariableConstant aux_v1 = taulaSimbols.usarVariableConstant(v1.getValue());
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v2.getTipus() == TipusDades.NULL){
            print_this("Error semántico ASIG_SENT");
            String e = ("Valor no asignado");
            semantic_error(e, v2);
        }else{
            if(aux_v1.getValue() != ""){
                if(!aux_v1.isEsConstant()){
                    if(aux_v1.getTipus() != aux_v2.getTipus()){
                        print_this("Error semántico ASIG_SENT");
                        String e = ("Se está intentando asignar un tipo incorrecto a la variable " + v1.getValue());
                        semantic_error(e, v1);
                    }else{
                        RESULT = aux_v1;
                    }
                }else{
                    print_this("Error semántico ASIG_SENT");
                    String e = ("Se esta intentando asignar un nuevo valor a la constante " + v1.getValue());
                    semantic_error(e, v1);
                }
            }else{
                print_this("Error semántico ASIG_SENT");
                String e = ("La variable " + v1.getValue() + " no ha sido declarada");
                semantic_error(e, v1);
            }
        }
    }
:}
;

IF_SENT ::= if_t lparen EXP:v1 rparen colon COS else_t colon COS endif
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico IF_SENT");
            String e = ("Debes asignar una condición al if");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico IF_SENT");
                String e = ("La condición de la sentencia 'if' no es correcta");
                semantic_error(e, v1);
            }
        }
    }
:}
          | if_t lparen EXP:v1 rparen colon COS endif
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico IF_SENT");
            String e = ("Debes asignar una condición al if");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico IF_SENT");
                String e = ("La condición de la sentencia 'if' no es correcta");
                semantic_error(e, v1);
            }
        }
    }
:}
;

WHILE_SENT ::= while_t lparen EXP:v1 rparen colon COS endwhile
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico WHILE_SENT");
            String e = ("Debes asignar una condición al bucle");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico WHILE_SENT");
                String e = ("La condición de la sentencia 'while' no es correcta");
                semantic_error(e, v1);
            }
        }
    }
:}
;

FOR_SENT ::= for_t FORINIT:v1 to FORLIMIT:v2 colon COS endfor
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición init de la sentencia 'for' no es correcta");
            semantic_error(e, v1);
        }else if(aux_v2.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición limit de la sentencia 'for' no es correcta");
            semantic_error(e, v2);
        }
    }
:}
;

TUPLA_ASSIGN ::= TUPLA_ACCESS:v1 assign EXP:v2 semicolon
{:
    if(!error_detectat){
        Tupla aux_v1 = (Tupla) v1;
        Simbol aux_v2 = (Simbol) v2;
        print_this("Asignando valor a Tupla: "+ aux_v1.getValue());
        if(aux_v2.getTipus() == TipusDades.NULL){
            print_this("Error semántico TUPLA_ASSIGN");
            String e = ("Valor no asignado");
            semantic_error(e, v2);
        }else{
            if(aux_v1.getTipus() != aux_v2.getTipus()){
                print_this("Error semántico TUPLA_ASSIGN");
                String e = ("A la tupla " + aux_v1.getValue() + " se le esta asignando un tipo incorrecto.");
                semantic_error(e, v1);
            }
            RESULT = v1;
        }
    }
:}
;

ENTR_SENT ::= in lparen TIPO:v1 rparen semicolon {: RESULT = v1; :};

SAL_SENT ::= out lparen OUT_EXP:v1 rparen semicolon
{:
    Simbol aux_v1 = (Simbol) v1;
    if(aux_v1.getTipus() == TipusDades.NULL){
        print_this("Error semántico SAL_SENT");
        String e = ("Salida vacía");
        semantic_error(e, v1);
    }else{
        RESULT = aux_v1;
    }
:}
;

CRID_FUNC ::= id:v1 lparen ARGS:v2 rparen
{:
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
        if(aux_v1.getValue() != ""){
            if(aux_v1.mateixosParametres(aux_v2)){
                RESULT = aux_v1;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + v1.getValue() + " no se le estan pasando los parámetros correctos");
                semantic_error(e, aux_v2.get(0));
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
            | id:v1 lparen rparen
{:
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        if(aux_v1.getValue() != ""){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
;

FUNC_DECL ::= fnct TIPO:v1 id:v2 lparen PARAM_LIST:v3 rparen colon COS FINAL_RTN:v4 endfnct
{:
    if(!error_detectat){
        print_this("Declarando Función: "+ v2.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        ArrayList<VariableConstant> aux_v3 = (ArrayList<VariableConstant>) v3;
        Simbol aux_v4 = (Simbol) v4;
        for(int i = 0; i < aux_v3.size() && !error_detectat; i++){
            print_this(aux_v3.get(i).toString());
            error_detectat = !taulaSimbols.declararVariableConstant(aux_v3.get(i));
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una variable con el nombre "+ aux_v3.get(i).getValue());
                semantic_error(e, aux_v3.get(i));
            }
        }
        if(!error_detectat){
            if(aux_v4.getTipus() != aux_v1.getTipus()){
                print_this("Error semántico FUNC_DECL");
                String e = ("El valor devuelto no corresponde con el tipo de la función.");
                semantic_error(e, v4);
            }
        }
        if(!error_detectat){
            error_detectat = !taulaSimbols.declararFuncio(new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus()));
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
                semantic_error(e, v2);
            }else{
                print_this("Función '" + v2.getValue() + " de tipo " + aux_v1.getTipus().toString() + " creada con éxito");
                RESULT = new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus());
            }
        }
    }
:}
            | fnct TIPO:v1 id:v2 lparen PARAM_LIST:v3 rparen colon FINAL_RTN:v4 endfnct
{:
    if(!error_detectat){
        print_this("Declarando Función: "+ v2.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        ArrayList<VariableConstant> aux_v3 = (ArrayList<VariableConstant>) v3;
        Simbol aux_v4 = (Simbol) v4;
        for(int i = 0; i < aux_v3.size() && !error_detectat; i++){
            print_this(aux_v3.get(i).toString());
        }
        if(!error_detectat){
            if(aux_v4.getTipus() != aux_v1.getTipus()){
                print_this("Error semántico FUNC_DECL");
                String e = ("El valor devuelto no corresponde con el tipo de la función.");
                semantic_error(e, v4);
            }
        }
        if(!error_detectat){
            error_detectat = !taulaSimbols.declararFuncio(new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus()));
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
                semantic_error(e, v2);
            }else{
                print_this("Función '" + v2.getValue() + " de tipo " + aux_v1.getTipus().toString() + " creada con éxito");
                RESULT = new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus());
            }
        }
    }
:}
;

FINAL_RTN ::= rtrn lparen EXP:v1 rparen semicolon
{:
    Simbol aux_v1 = (Simbol) v1;
    if(aux_v1.getTipus() == TipusDades.NULL){
        print_this("Error semántico FINAL_RTN");
        String e = ("No se ha devuelto ningún valor");
        semantic_error(e, v1);
    }else{
        RESULT = aux_v1;
    }
:};

VAR_DECL ::= val id:v1 double_colon TIPO:v2 assign EXP:v3 semicolon
{:
    if(!error_detectat){
        print_this("Declarando Variable "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        if(aux_v3.getTipus() == TipusDades.NULL){
            print_this("Error semántico VAR_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, v3);
        }else{
            error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), false));
            if(error_detectat){
                print_this("Error semántico VAR_DECL");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Variable '" + v1.getValue() + "' creada con éxito");
                RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), false);
            }
        }
    }
:}
;

CONS_DECL ::= con id:v1 double_colon TIPO:v2 assign EXP:v3 semicolon
{:
    if(!error_detectat){
        print_this("Declarando Constante "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        if(aux_v3.getTipus() == TipusDades.NULL){
            print_this("Error semántico CONS_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, v3);
        }else{
            error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), true));
            if(error_detectat){
                print_this("Error semántico CONS_DECL");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Constante '" + v1.getValue() + "' creada con éxito");
                RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), true);
            }
        }
    }
:}
;

TUPLA_DECL ::= tuple id:v1 assign lbrace TIPO:v2 comma TIPO:v3 rbrace semicolon
{:
    if(!error_detectat){
        print_this("Declarando Tupla: "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        error_detectat = !taulaSimbols.declararTupla(new Tupla(v1.getValue(), aux_v2.getTipus(), aux_v3.getTipus()));
        if(error_detectat){
            print_this("Error semántico TUPLA_DECL");
            String e = ("Ya existe una tupla con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Tupla '" + v1.getValue() + "["+ aux_v2.getTipus().toString() +", "+ aux_v3.getTipus().toString() +"]' creada con éxito");
            RESULT = new Tupla(v1.getValue(), aux_v2.getTipus(), aux_v3.getTipus());
        }
    }
:}
;

EXP ::= LOG_TERM:v1     {: RESULT = v1;:}
      | ARIT_TERM:v1    {: RESULT = v1;:}
      | CRID_FUNC:v1    {: RESULT = v1;:}
      | id:v1
{:
    Simbol aux_v1 = taulaSimbols.usarSimbol(v1.getValue());
    if(aux_v1.getValue() == ""){
        print_this("Error semántico EXP");
        String e = ("El símbolo llamado no ha sido declarado");
        semantic_error(e, v1);
    }
    RESULT = aux_v1;
:}
      | TUPLA_ACCESS:v1 {: RESULT = v1;:}
      | LIT:v1          {: RESULT = v1;:}
      | ENTR_FUNC:v1    {: RESULT = v1;:}
      | SAL_FUNC:v1     {: RESULT = v1;:}
      ;

LIT ::= NEG_ENT_LIT:v1 {: RESULT = v1;:}
     | BOL_LIT:v1 {: RESULT = v1;:}
     ;

NEG_ENT_LIT ::= minus integer_literal:v1 {: RESULT = v1; :};

BOL_LIT ::= boolean_literal:v1 {: RESULT = v1;:};

FORINIT ::= VAR_DECL:v1 {: RESULT = v1;:}
         | EXP:v1
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORINIT");
            String e = ("Inicio del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:}
;

FORLIMIT ::= CONS_DECL:v1 {: RESULT = v1;:}
           | EXP:v1
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORLIMIT");
            String e = ("Límite del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:}
;

TUPLA_ACCESS ::= id:v1 lbracket integer_literal:v2 rbracket
{:
    if(!error_detectat){
        print_this("Accediendo a la Tupla: " + v1.getValue() + "(" + v2.getValue() + ")");
        Simbol aux_v1 = (Simbol) v1;
        Integer index = (Integer) v2.getValue();
        Tupla aux_tupla = taulaSimbols.usarTupla(v1.getValue());
        if(aux_tupla.getValue() != ""){
            if(index == 0 || index == 1){
                aux_tupla.setTipus(aux_tupla.getTipus(index));
                RESULT = aux_tupla;
            }else{
                print_this("Error semántico TUPLA_ACCESS");
                String e = ("El índice '" + index + "' de la tupla " + v1.getValue() + " no es correcto. Los índices de tupla solo permíten 0 o 1.");
                semantic_error(e, v2);
            }
        }else{
            print_this("Error semántico TUPLA_ACCESS");
            String e = ("La tupla " + v1.getValue() + " no ha sido declarada.");
            semantic_error(e, v1);
        }
    }
:}
;

TIPO ::= integer {: RESULT = new Simbol("integer", TipusDades.INTEGER); :}
       | logical {: RESULT = new Simbol("logical", TipusDades.BOOLEAN); :}
       ;

OUT_EXP ::= id:v1
{:
    Simbol aux_v1 = taulaSimbols.usarSimbol(v1.getValue());
    if(aux_v1.getValue() == ""){
        print_this("Error semántico OUT_EXP");
        String e = ("El símbolo llamado no ha sido declarado");
        semantic_error(e, v1);
    }
    RESULT = aux_v1;
:}
          | CRID_FUNC:v1 {: RESULT = v1;:}
          | ARIT_TERM:v1 {: RESULT = v1;:}
          | LOG_TERM:v1  {: RESULT = v1;:}
          ;

ARGS ::= EXP:v1 ARGS_LIST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            RESULT = new ArrayList<Simbol>();
        }else{
            ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
            aux_v2.add(0, aux_v1);
            RESULT = aux_v2;
        }
    }
:}
;

ARGS_LIST ::= comma EXP:v1 ARGS_LIST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico ARGS_LIST");
            String e = ("Argumento vacío");
            semantic_error(e, v1);
        }else{
            ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
            aux_v2.add(0, aux_v1);
            RESULT = aux_v2;
        }
    }
:}
            | /* epsilon */ {: RESULT = new ArrayList<Simbol>(); :}
            ;

PARAM_LIST ::= PARAM:v1
{:
    if(!error_detectat){
        RESULT = new ArrayList<VariableConstant>(Arrays.asList((VariableConstant) v1));
    }
:}
             | PARAM:v1 comma PARAM_LIST:v2
{:
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        ArrayList<VariableConstant> aux_v2 = (ArrayList<VariableConstant>) v2;
        aux_v2.add(0, aux_v1);
        RESULT = aux_v2;
    }
:}
             | /* epsilon */ {: RESULT = new ArrayList<VariableConstant>(); :}
             ;

PARAM ::= id:v1 double_colon TIPO:v2
{:
    if(!error_detectat){
        print_this("Declarando Parámetro "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), false));
        if(error_detectat){
            print_this("Error semántico PARAM");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Parámetro '" + v1.getValue() + "' creado con éxito");
            RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), false);
        }
    }
:}
;

LOG_TERM ::= EXP:v1 equal EXP:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
                if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                if(aux_v1.getTipus() == aux_v2.getTipus()){
                    print_this(aux_v1.getValue() + " equal " + aux_v2.getValue());
                    aux_v1.setTipus(TipusDades.BOOLEAN);
                    RESULT = aux_v1;
                }else{
                    print_this("Error semántico LOG_TERM");
                    String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
                    semantic_error(e, v1);
                }
            }
        }
    }
:}
           | EXP:v1 not_equal EXP:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                if(aux_v1.getTipus() == aux_v2.getTipus()){
                    print_this(aux_v1.getValue() + " not_equal "+aux_v2.getValue());
                    aux_v1.setTipus(TipusDades.BOOLEAN);
                    RESULT = aux_v1;
                }else{
                    print_this("Error semántico LOG_TERM");
                    String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
                    semantic_error(e, v1);
                }
            }
        }
    }
:}
           | EXP:v1 and EXP:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                print_this(aux_v1.getValue() + " and " + aux_v2.getValue());
                aux_v1.setTipus(TipusDades.BOOLEAN);
                RESULT = aux_v1;
            }
        }
    }
:}
           | EXP:v1 or EXP:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                print_this(aux_v1.getValue() + " or " + aux_v2.getValue());
                aux_v1.setTipus(TipusDades.BOOLEAN);
                RESULT = aux_v1;
            }
        }
    }
:}
;

ARIT_TERM ::= ARIT_FACTOR:v1 ARIT_TERM_REST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus() || aux_v2.getTipus() ==  TipusDades.NULL){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }
:}
;

ARIT_TERM_REST ::= plus ARIT_FACTOR:v1 ARIT_TERM_REST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus()){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM_REST");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }
:}
                 | minus ARIT_FACTOR:v1 ARIT_TERM_REST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus()){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM_REST");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }
:}
                 | /* epsilon */ {: RESULT = new Simbol(); :}
                 ;

ARIT_FACTOR ::= lparen EXP:v1 rparen
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico ARIT_FACTOR");
            String e = ("Factor aritmético vacío");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:}
              | POS_ENT_LIT:v1 {: RESULT = v1;:}
              ;

POS_ENT_LIT ::= integer_literal:v1 {: RESULT = v1;:};

ENTR_FUNC ::= in lparen TIPO:v1 rparen {: RESULT = v1; :};

SAL_FUNC ::= out lparen OUT_EXP:v1 rparen
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico SAL_FUNC");
            String e = ("La funcion de salida out esta vacía");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:};
