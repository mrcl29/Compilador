package compiler.sintactic;
/**
 * parser.cup
 *
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 *
 * Marc Llobera Villalonga
 */

import java.lang.Exception;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import compiler.sintactic.Symbols.TaulaSimbols;
import compiler.sintactic.Symbols.Simbol;

class Parser;

parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/

    TaulaSimbols taulaSimbols = new TaulaSimbols();

    public boolean errorSemantic = false;
    public boolean error_generico = false;

    public boolean DEBUG = true;
    public void print_this(String msg){
        if(DEBUG){
            System.out.println(msg);
        }
    }

    public boolean declararVariableConstant(Object id, String tipus, boolean constant){
        try{
            return taulaSimbols.declararVariableConstant(id, tipus, constant);
        }catch(Exception e){
            System.err.println(e);
        }
        return false;
    }

    public boolean declararTupla(Object id, String tipus1, String tipus2){
        try{
            return taulaSimbols.declararTupla(id, tipus1, tipus2);
        }catch(Exception e){
            System.err.println(e);
        }
        return false;
    }

    public boolean declararFuncio(Object id, ArrayList<> parametres, String tipus){
        try{
            return taulaSimbols.declararFuncio(id, parametres, tipus);
        }catch(Exception e){
            System.err.println(e);
        }
        return false;
    }

    /**************************************************************
    ************************ GESTIÓ ERRORS ************************
    **************************************************************/

    @Override
    public void syntax_error(Symbol s) {
        report_error("Error sintáctico", s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        report_error("Error sintáctico inrrecuperable", s);
        done_parsing();
    }

    @Override
    public void report_error(String t, Object info) {
        print_this("Reportando error...");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();

            System.err.println("Error en la linea " + l.getLine() + " y columna " + l.getColumn() + " --> " + t);
        }else{
            print_error("info no es Symbol en report_error");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal ("+message+")", info);
        done_parsing();
    }

    /**
    * Mètode per mostrar un error semàntic
    **/
    public void semantic_error(String t, Object info){
        print_this("Imprimiendo error semántico...");
        if(info instanceof Simbol){
            Simbol token = (Simbol) info;

            System.err.println("Error semántico en la linea " + token.getFila() + " y columna " + token.getColumna() + " --> " + t);
        }else{
            print_error("info no es Symbol en semantic_error");
        }
        done_parsing();
    }

    /**
    * Mètode per mostrar un error genèric
    **/
    public void print_error(String msg){
        error_generico = true;
        print_this("Imprimiendo error genérico...");
        System.err.println("Error--> " + msg);
        done_parsing();
    }
:}

/* Definición de terminales (tokens) */
terminal fnct, endfnct, rtrn, val, con, if_t, else_t, endif, while_t, endwhile, for_t, to, endfor, in, out, tuple;
terminal integer, logical;
terminal assign, plus, minus, equal, not_equal, and, or;
terminal lparen, rparen, colon, double_colon, semicolon, comma, lbrace, rbrace, lbracket, rbracket;
terminal Simbol integer_literal;
terminal Simbol boolean_literal;
terminal Simbol id;

/* No terminales */
non terminal S, P, DECL, VAR_DECL, CONS_DECL, TUPLA_DECL, FUNC_DECL, PARAM_LIST, PARAM, COS, FINAL_RTN, SENT;
non terminal ASIG_SENT, IF_SENT, WHILE_SENT, FOR_SENT, FORINIT, FORLIMIT, TUPLA_ASSIGN, ENTR_SENT, SAL_SENT, CRID_FUNC, ARGS, ARGS_LIST;
non terminal TIPO, EXP, ARIT_TERM, ARIT_FACTOR, ARIT_TERM_REST, LOG_TERM, TUPLA_ACCESS, LIT, POS_ENT_LIT, NEG_ENT_LIT, BOL_LIT, OUT_EXP, ENTR_FUNC, SAL_FUNC;

/* Precedencia y asociatividad */
precedence left and, or;        // Menor precedencia
precedence left equal, not_equal; // Operadores relacionales === y /=
precedence left plus, minus;      // Operadores aritméticos + y -

/* Símbolo inicial */
start with S;

/* Reglas de gramática */

S ::= P ;

P ::= DECL P    {:  :}
  | DECL        {:  :}
  ;

DECL ::= VAR_DECL   {:  :}
      | CONS_DECL   {:  :}
      | TUPLA_DECL  {:  :}
      | FUNC_DECL   {:  :}
      | SENT        {:  :}
      ;

VAR_DECL ::= val id:v1 double_colon TIPO:v2 assign EXP semicolon
{:
    if(!errorSemantic && !error_generico){
        print_this("Declarando Variable '"+ v1.getValue() +"' de tipo '" + v2.toString() + "'");
        errorSemantic = !declararVariableConstant(v1.getValue(), v2.toString(), false);
        if(!error_generico){
            if(errorSemantic){
                print_this("Error semántico");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Variable '" + v1.getValue() + "' creada con éxito");
            }
        }
    }
:}
;

CONS_DECL ::= con id:v1 double_colon TIPO:v2 assign EXP semicolon
{:
    if(!errorSemantic && !error_generico){
        print_this("Declarando Constante '"+ v1.getValue() +"' de tipo '" + v2.toString() + "'");
        errorSemantic = !declararVariableConstant(v1.getValue(), v2.toString(), true);
        if(!error_generico){
            if(errorSemantic){
                print_this("Error semántico");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Constante '" + v1.getValue() + "' creada con éxito");
            }
        }
    }
:}
;

TUPLA_DECL ::= tuple id:v1 assign lbrace TIPO:v2 comma TIPO:v3 rbrace semicolon
{:
    if(!errorSemantic && !error_generico){
        print_this("Declarando Tupla: '"+ v1.getValue() +"' de [tipo1: "+ v2.toString() +", tipo2: "+ v3.toString() +"]");
        errorSemantic = !declararTupla(v1.getValue(), v2.toString(), v3.toString());
        if(!error_generico){
            if(errorSemantic){
                print_this("Error semántico");
                String e = ("Ya existe una tupla con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Tupla '" + v1.getValue() + "["+ v2.toString() +", "+ v3.toString() +"]' creada con éxito");
            }
        }
    }
:}
;

FUNC_DECL ::= fnct TIPO id lparen PARAM_LIST rparen colon COS FINAL_RTN endfnct
            | fnct TIPO id lparen PARAM_LIST rparen colon FINAL_RTN endfnct
            ;

PARAM_LIST ::= PARAM
             | PARAM comma PARAM_LIST
             | /* epsilon */ ;

PARAM ::= id double_colon TIPO ;

COS ::= SENT COS
     | SENT ;

FINAL_RTN ::= rtrn lparen EXP rparen semicolon ;

SENT ::= ASIG_SENT
      | IF_SENT
      | WHILE_SENT
      | FOR_SENT
      | TUPLA_ASSIGN
      | ENTR_SENT
      | SAL_SENT
      | CRID_FUNC ;

ASIG_SENT ::= id assign EXP semicolon ;

IF_SENT ::= if_t lparen EXP rparen colon COS else_t colon COS endif
         | if_t lparen EXP rparen colon COS endif ;

WHILE_SENT ::= while_t lparen EXP rparen colon COS endwhile ;

FOR_SENT ::= for_t FORINIT to FORLIMIT colon COS endfor ;

FORINIT ::= VAR_DECL
         | EXP ;

FORLIMIT ::= CONS_DECL
           | EXP ;

TUPLA_ASSIGN ::= TUPLA_ACCESS assign EXP semicolon ;

ENTR_SENT ::= in lparen TIPO rparen semicolon ;

SAL_SENT ::= out lparen OUT_EXP rparen semicolon ;

ENTR_FUNC ::= in lparen TIPO rparen ;

SAL_FUNC ::= out lparen OUT_EXP rparen ;

OUT_EXP ::= id
          | CRID_FUNC
          | ARIT_TERM
          | LOG_TERM ;

CRID_FUNC ::= id lparen ARGS rparen
           | id lparen rparen ;

ARGS ::= EXP ARGS_LIST ;

ARGS_LIST ::= comma EXP ARGS_LIST
            | /* epsilon */ ;

TIPO ::= integer {: RESULT = "INTEGER"; :}
       | logical {: RESULT = "BOOLEAN"; :}
;

EXP ::= LOG_TERM
     | ARIT_TERM
     | CRID_FUNC
     | id
     | TUPLA_ACCESS
     | LIT
     | ENTR_FUNC
     | SAL_FUNC ;

ARIT_TERM ::= ARIT_FACTOR ARIT_TERM_REST ;

ARIT_TERM_REST ::= plus ARIT_FACTOR ARIT_TERM_REST
                 | minus ARIT_FACTOR ARIT_TERM_REST
                 | /* epsilon */ ;

ARIT_FACTOR ::= lparen EXP rparen
              | POS_ENT_LIT ;

LOG_TERM ::= EXP equal EXP
           | EXP not_equal EXP
           | EXP and EXP
           | EXP or EXP ;

TUPLA_ACCESS ::= id:v1 lbracket integer_literal:v2 rbracket
{:
RESULT = (String) v1.getValue();
RESULT = "[";
RESULT = (Integer) v2.getValue();
RESULT = "]";
:};

LIT ::= NEG_ENT_LIT
     | BOL_LIT ;

POS_ENT_LIT ::= integer_literal:v {: RESULT = (Integer)v.getValue(); :};

NEG_ENT_LIT ::= minus integer_literal:v {: RESULT = -1*(Integer)v.getValue(); :};

BOL_LIT ::= boolean_literal:v {: RESULT = v.getValue(); :};
