package compiler.sintactic;
/**
 * parser.cup
 *
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 *
 * Marc Llobera Villalonga
 */

import java.lang.Exception;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import compiler.sintactic.Symbols.*;

class Parser;

parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/

    TaulaSimbols taulaSimbols = new TaulaSimbols();

    public boolean error_detectat = false;

    public boolean DEBUG = true;
    public void print_this(Object msg){
        if(DEBUG){
            System.out.println(msg);
        }
    }

    /**************************************************************
    ************************ GESTIÓ ERRORS ************************
    **************************************************************/

    @Override
    public void syntax_error(Symbol s) {
        report_error("Error sintáctico", s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        report_error("Error sintáctico inrrecuperable", s);
        done_parsing();
    }

    @Override
    public void report_error(String t, Object info) {
        print_this("Reportando error...");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();

            print_error("Error en la linea " + l.getLine() + " y columna " + l.getColumn() + " --> " + t);
        }else{
            print_error("info no es Symbol en report_error");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal ("+message+")", info);
        done_parsing();
    }

    /**
    * Mètode per mostrar un error semàntic
    **/
    public void semantic_error(String t, Object info){
        print_this("Imprimiendo error semántico...");
        if(info instanceof Simbol){
            Simbol token = (Simbol) info;

            print_error("Error semántico en la linea " + token.getFila() + " y columna " + token.getColumna() + " --> " + t);
        }else{
            print_error("info no es Symbol en semantic_error");
        }
        done_parsing();
    }

    /**
    * Mètode per mostrar un error
    **/
    public void print_error(String msg){
        error_detectat = true;
        System.err.println("Error--> " + msg);
        done_parsing();
    }
:}

/* Definición de terminales (tokens) */
terminal Simbol fnct, endfnct, rtrn, val, con, if_t, else_t, endif, while_t, endwhile, for_t, to, endfor, in, out, tuple;
terminal Simbol integer, logical;
terminal Simbol assign, plus, minus, equal, not_equal, and, or;
terminal Simbol lparen, rparen, colon, double_colon, semicolon, comma, lbrace, rbrace, lbracket, rbracket;
terminal Simbol integer_literal;
terminal Simbol boolean_literal;
terminal Simbol id;

/* No terminales */
non terminal S, P, DECL, VAR_DECL, CONS_DECL, TUPLA_DECL, FUNC_DECL, PARAM_LIST, PARAM, COS, FINAL_RTN, SENT;
non terminal ASIG_SENT, IF_SENT, WHILE_SENT, FOR_SENT, FORINIT, FORLIMIT, TUPLA_ASSIGN, ENTR_SENT, SAL_SENT, CRID_FUNC, ARGS, ARGS_LIST;
non terminal TIPO, EXP, ARIT_TERM, ARIT_FACTOR, ARIT_TERM_REST, LOG_TERM, TUPLA_ACCESS, LIT, POS_ENT_LIT, NEG_ENT_LIT, BOL_LIT, OUT_EXP, ENTR_FUNC, SAL_FUNC;

/* Precedencia y asociatividad */
precedence left and, or;        // Menor precedencia
precedence left equal, not_equal; // Operadores relacionales === y /=
precedence left plus, minus;      // Operadores aritméticos + y -

/* Símbolo inicial */
start with S;

/* Reglas de gramática */

S ::= P ;

P ::= COS
    | FUNC_DECL P
    | FUNC_DECL
    ;

COS ::= SENT COS
      | SENT
      ;

SENT ::= DECL
       | ASIG_SENT
       | IF_SENT
       | WHILE_SENT
       | FOR_SENT
       | TUPLA_ASSIGN
       | ENTR_SENT
       | SAL_SENT
       | CRID_FUNC
       ;

DECL ::= VAR_DECL
       | CONS_DECL
       | TUPLA_DECL
       ;

ASIG_SENT ::= id:v1 assign EXP:v2 semicolon
{:
    if(!error_detectat ){
        VariableConstant aux_v1 = taulaSimbols.usarVariableConstant(v1.getValue());
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getValue() != ""){
            if(!aux_v1.isEsConstant()){
                if(aux_v1.getTipus() != aux_v2.getTipus()){
                    print_this("Error semántico ASIG_SENT");
                    String e = ("Se está intentando asignar un tipo incorrecto a la variable " + v1.getValue());
                    semantic_error(e, v1);
                }
            }else{
                print_this("Error semántico ASIG_SENT");
                String e = ("Se esta intentando asignar un nuevo valor a la constante " + v1.getValue());
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico ASIG_SENT");
            String e = ("La variable " + v1.getValue() + " no ha sido declarada");
            semantic_error(e, v1);
        }
    }
:}
;

IF_SENT ::= if_t:v1 lparen EXP:v2 rparen colon COS else_t colon COS endif
{:
    if(!error_detectat){
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v2.getTipus() != TipusDades.BOOLEAN){
            print_this("Error semántico IF_SENT");
            String e = ("La condición de la sentencia 'if' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
          | if_t:v1 lparen EXP:v2 rparen colon COS endif
{:
    if(!error_detectat){
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v2.getTipus() != TipusDades.BOOLEAN){
            print_this("Error semántico IF_SENT");
            String e = ("La condición de la sentencia 'if' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
;

WHILE_SENT ::= while_t:v1 lparen EXP:v2 rparen colon COS endwhile
{:
    if(!error_detectat){
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v2.getTipus() != TipusDades.BOOLEAN){
            print_this("Error semántico WHILE_SENT");
            String e = ("La condición de la sentencia 'while' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
;

FOR_SENT ::= for_t:v1 FORINIT:v2 to FORLIMIT:v3 colon COS endfor
{:
    if(!error_detectat){
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        if(aux_v2.getTipus() != TipusDades.INTEGER || aux_v3.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición de la sentencia 'for' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
;

TUPLA_ASSIGN ::= TUPLA_ACCESS:v1 assign EXP:v2 semicolon
{:
    if(!error_detectat){
        Tupla aux_v1 = (Tupla) v1;
        Simbol aux_v2 = (Simbol) v2;
        print_this("Asignando valor a Tupla: "+ aux_v1.getValue());
        if(aux_v1.getTipus() != aux_v2.getTipus()){
            print_this("Error semántico TUPLA_ASSIGN");
            String e = ("A la tupla " + aux_v1.getValue() + " se le esta asignando un tipo incorrecto.");
            semantic_error(e, aux_v1);
        }
    }
:}
;

ENTR_SENT ::= in lparen TIPO:v1 rparen semicolon {: RESULT = v1; :};

SAL_SENT ::= out lparen OUT_EXP:v1 rparen semicolon {: RESULT = v1; :};

CRID_FUNC ::= id:v1 lparen ARGS:v2 rparen
{:
    if(!error_detectat){
        ArrayList<TipusDades> aux_v2 = (ArrayList<TipusDades>) v2;
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux = taulaSimbols.usarFuncio(v1);
        if(aux.getValue() != ""){
            if(aux.mateixosParametres(aux_v2)){
                RESULT = aux;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + v1.getValue() + " no se le estan pasando los parámetros correctos");
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
            | id:v1 lparen rparen
{:
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux = taulaSimbols.usarFuncio(v1);
        if(aux.getValue() != ""){
            RESULT = aux;
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
;

FUNC_DECL ::= fnct TIPO:v1 id:v2 lparen PARAM_LIST:v3 rparen colon COS FINAL_RTN:v4 endfnct
{:
    if(!error_detectat){
        print_this("Declarando Función: '"+ v2.getValue() +"' de tipo '" + v1.toString() + "' y con los parámetros:");
        ArrayList<VariableConstant> aux = (ArrayList<VariableConstant>) v3;
        for(int i = 0; i < aux.size() && !error_detectat; i++){
            print_this(aux.get(i).toString());
            error_detectat = !taulaSimbols.declararVariableConstant(aux.get(i), v2.toString());
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una variable con el nombre "+ aux.get(i).getValue());
                semantic_error(e, v2);
            }
        }
        if(!error_detectat){
            error_detectat = !taulaSimbols.declararFuncio(v2.getValue(), aux, v1.toString());
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
                semantic_error(e, v2);
            }else{
                print_this("Función '" + v2.getValue() + " de tipo " + v1.toString() + " creada con éxito");
            }
        }
    }
:}
            | fnct TIPO:v1 id:v2 lparen PARAM_LIST:v3 rparen colon FINAL_RTN endfnct
            ;

VAR_DECL ::= val id:v1 double_colon TIPO:v2 assign EXP semicolon
{:
    if(!error_detectat){
        print_this("Declarando Variable '"+ v1.getValue() +"' de tipo '" + v2.toString() + "'");
        VariableConstant aux = new VariableConstant(v1.getValue(), (TipusDades) v2, false);
        error_detectat = !taulaSimbols.declararVariableConstant(aux);
        if(error_detectat){
            print_this("Error semántico VAR_DECL");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Variable '" + v1.getValue() + "' creada con éxito");
            RESULT = aux;
        }
    }else{
        RESULT = new VariableConstant();
    }
:}
;

CONS_DECL ::= con id:v1 double_colon TIPO:v2 assign EXP semicolon
{:
    if(!error_detectat){
        print_this("Declarando Constante '"+ v1.getValue() +"' de tipo '" + v2.toString() + "'");
        VariableConstant aux = new VariableConstant(v1.getValue(), (TipusDades) v2, true);
        error_detectat = !taulaSimbols.declararVariableConstant(aux);
        if(error_detectat){
            print_this("Error semántico CONS_DECL");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Constante '" + v1.getValue() + "' creada con éxito");
            RESULT = aux;
        }
    }else{
        RESULT = new VariableConstant();
    }
:}
;

TUPLA_DECL ::= tuple id:v1 assign lbrace TIPO:v2 comma TIPO:v3 rbrace semicolon
{:
    if(!error_detectat){
        print_this("Declarando Tupla: '"+ v1.getValue() +"' de [tipo1: "+ v2.toString() +", tipo2: "+ v3.toString() +"]");
        Tupla aux = new Tupla(v1.getValue(), (TipusDades) v2, (TipusDades) v3);
        error_detectat = !taulaSimbols.declararTupla(aux);
        if(error_detectat){
            print_this("Error semántico TUPLA_DECL");
            String e = ("Ya existe una tupla con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Tupla '" + v1.getValue() + "["+ v2.toString() +", "+ v3.toString() +"]' creada con éxito");
            RESULT = aux;
        }
    }else{
        RESULT = new Tupla();
    }
:}
;

EXP ::= LOG_TERM
      | ARIT_TERM
      | CRID_FUNC
      | id:v1 {: RESULT = taulaSimbols.usarSimbol(v1.getValue()); :}
      | TUPLA_ACCESS
      | LIT
      | ENTR_FUNC
      | SAL_FUNC
      ;

FORINIT ::= VAR_DECL
         | EXP
         ;

FORLIMIT ::= CONS_DECL
           | EXP
           ;

TUPLA_ACCESS ::= id:v1 lbracket integer_literal:v2 rbracket
{:
    if(!error_detectat){
        print_this("Accediendo a la Tupla: " + v1.getValue() + "(" + v2.getValue() + ")");
        Tupla aux = taulaSimbols.usarTupla(v1.getValue());
        if(aux.getValue() != ""){
            Integer index = (Integer) v2.getValue();
            if(index == 0 || index == 1){
                aux.setTipus(aux.getTipus(index));
                RESULT = aux;
            }else{
                print_this("Error semántico TUPLA_ACCESS");
                String e = ("El índice '" + index + "' de la tupla " + v1.getValue() + " no es correcto. Los índices de tupla solo permíten 0 o 1.");
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico TUPLA_ACCESS");
            String e = ("La tupla " + v1.getValue() + " no ha sido declarada.");
            semantic_error(e, v1);
        }
    } else {
        RESULT = new Tupla();
    }
:}
;

TIPO ::= integer {: RESULT = new Simbol("", TipusDades.INTEGER); :}
       | logical {: RESULT = new Simbol("", TipusDades.BOOLEAN); :}
       ;

OUT_EXP ::= id:v1 {: RESULT = taulaSimbols.usarSimbol(v1.getValue()); :}
          | CRID_FUNC
          | ARIT_TERM
          | LOG_TERM
          ;

ARGS ::= EXP:v1 ARGS_LIST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        ArrayList<TipusDades> aux_v2 = (ArrayList<TipusDades>) v2;
        aux_v2.add(0, aux_v1.getTipus());
        RESULT = aux_v2;
    }else{
        RESULT = new ArrayList<TipusDades>();
    }
:}
;

PARAM_LIST ::= PARAM:v1 {: RESULT = new ArrayList<VariableConstant>(Arrays.asList((VariableConstant) v1)); :}
             | PARAM:v1 comma PARAM_LIST:v2
{:
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        ArrayList<VariableConstant> aux_v2 = (ArrayList<VariableConstant>) v2;
        aux_v2.add(0, aux_v1);
        RESULT = aux_v2;
    }else{
        RESULT = new ArrayList<VariableConstant>();
    }
:}
             | /* epsilon */ {: RESULT = new ArrayList<TipusDades>(); :}
             ;

FINAL_RTN ::= rtrn lparen EXP:v1 rparen semicolon {: RESULT = v1; :};

LOG_TERM ::= EXP:v1 equal EXP:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus()){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico LOG_TERM");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }else{
        RESULT = new Simbol();
    }
:}
           | EXP:v1 not_equal EXP:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus()){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico LOG_TERM");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }else{
        RESULT = new Simbol();
    }
:}
           | EXP:v1 and EXP {: Simbol aux_v1 = (Simbol) v1;
                               aux_v1.setTipus(TipusDades.BOOLEAN);
                               RESULT = aux_v1; :}
           | EXP:v1 or EXP  {: Simbol aux_v1 = (Simbol) v1;
                               aux_v1.setTipus(TipusDades.BOOLEAN);
                               RESULT = aux_v1; :}
           ;

ARIT_TERM ::= ARIT_FACTOR:v1 ARIT_TERM_REST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus()){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }else{
        RESULT = new Simbol();
    }
:}
;

LIT ::= NEG_ENT_LIT
     | BOL_LIT
     ;

ENTR_FUNC ::= in lparen TIPO:v1 rparen {: RESULT = v1; :};

SAL_FUNC ::= out lparen OUT_EXP:v1 rparen {: RESULT = v1; :};

ARGS_LIST ::= comma EXP:v1 ARGS_LIST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        ArrayList<TipusDades> aux_v2 = (ArrayList<TipusDades>) v2;
        aux_v2.add(0, aux_v1.getTipus());
        RESULT = aux_v2;
    }else{
        RESULT = new ArrayList<TipusDades>();
    }
:}
            | /* epsilon */ {: RESULT = new ArrayList<TipusDades>(); :};

PARAM ::= id:v1 double_colon TIPO:v2 {: RESULT = new VariableConstant(v1.getValue(), (TipusDades) v2, false); :};

ARIT_FACTOR ::= lparen EXP:v1 rparen {: RESULT = v1; :}
              | POS_ENT_LIT
              ;

ARIT_TERM_REST ::= plus ARIT_FACTOR:v1 ARIT_TERM_REST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus()){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM_REST");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }else{
        RESULT = new Simbol();
    }
:}
                 | minus ARIT_FACTOR:v1 ARIT_TERM_REST:v2
{:
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus()){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM_REST");
            String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
            semantic_error(e, aux_v1);
        }
    }else{
        RESULT = new Simbol();
    }
:}
                 | /* epsilon */ {: RESULT = new Simbol(); :}
                 ;

NEG_ENT_LIT ::= minus integer_literal:v1 {: RESULT = v1; :};

BOL_LIT ::= boolean_literal;

POS_ENT_LIT ::= integer_literal;
