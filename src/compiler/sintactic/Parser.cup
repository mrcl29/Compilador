package compiler.sintactic;
/**
 * parser.cup
 *
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 *
 * Marc Llobera Villalonga
 */

import java.lang.Exception;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import compiler.sintactic.Symbols.*;
import compiler.c3a.*;

class Parser;

parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/

    TaulaSimbols taulaSimbols = new TaulaSimbols();

    public boolean error_detectat = false;

    public boolean DEBUG = false;
    public void print_this(Object msg){
        if(DEBUG){
            System.out.println(msg);
        }
    }

    GenerarCodi c3a = new GenerarCodi();

    int nbytes = 2;
    int buid = -2;

    /**************************************************************
    ************************ GESTIÓ ERRORS ************************
    **************************************************************/

    @Override
    public void syntax_error(Symbol s) {
        report_error("Error sintáctico", s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        report_error("Error sintáctico inrrecuperable", s);
        done_parsing();
    }

    @Override
    public void report_error(String t, Object info) {
        print_this("Reportando error...");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();

            print_error("Error en la linea " + l.getLine() + " y columna " + l.getColumn() + ": " + info.toString() + " --> " + t);
        }else{
            print_error("info no es Symbol en report_error");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal ("+message+")", info);
        done_parsing();
    }

    /**
    * Mètode per mostrar un error semàntic
    **/
    public void semantic_error(String t, Object info){
        if(info instanceof Simbol){
            Simbol token = (Simbol) info;

            print_error("Error semántico en la linea " + token.getFila() + " y columna " + token.getColumna() + " --> " + t);
        }else{
            print_error("info no es Symbol en semantic_error");
        }
        done_parsing();
    }

    /**
    * Mètode per mostrar un error
    **/
    public void print_error(String msg){
        error_detectat = true;
        System.err.println("Error--> " + msg);
        done_parsing();
    }
:}

/* Definición de terminales (tokens) */
terminal Simbol fnct, endfnct, rtrn, val, con, if_t, else_t, endif, while_t, endwhile, for_t, to, endfor, in, out, tuple;
terminal Simbol integer, logical;
terminal Simbol assign, plus, minus, equal, not_equal, and, or;
terminal Simbol lparen, rparen, colon, double_colon, semicolon, comma, lbrace, rbrace, lbracket, rbracket;
terminal Simbol integer_literal;
terminal Simbol boolean_literal;
terminal Simbol id;
terminal Simbol eof;

/* No terminales */
non terminal S, P, BODY, DECL, VAR_DECL, CONS_DECL, TUPLA_DECL, SENT;
non terminal FUNC_DECL, PARAM_LIST, PARAM, COS, FINAL_RTN;
non terminal CRID_FUNC_SENT, CRID_FUNC, ARGS, ARGS_LIST;
non terminal ASIG_SENT;
non terminal IF_SENT, IFINIT, IFELSE;
non terminal WHILE_SENT;
non terminal FOR_SENT, FORINIT, FORLIMIT;
non terminal SAL_SENT;
non terminal TIPO, EXP, CRID_SIMB, ARIT_TERM, LOG_TERM, TUPLA_ACCESS, LIT, ENT_LIT, POS_ENT_LIT, BOL_LIT, OUT_EXP, ENTR_FUNC;

/* Precedencia y asociatividad */
precedence left and, or;        // Menor precedencia
precedence left equal, not_equal; // Operadores relacionales === y /=
precedence left plus, minus;      // Operadores aritméticos + y -

/* Símbolo inicial */
start with S;

/* Reglas de gramática */

S ::= P ;

P ::= BODY
    | /* epsilon */;

BODY ::= SENT BODY
      | FUNC_DECL BODY
      | eof {: done_parsing(); :};

SENT ::= DECL
       | ASIG_SENT
       | IF_SENT
       | WHILE_SENT
       | FOR_SENT
       | SAL_SENT
       | CRID_FUNC_SENT
       ;

DECL ::= VAR_DECL
       | CONS_DECL
       | TUPLA_DECL
       ;

ASIG_SENT ::= id:v1 assign EXP:v2 semicolon
{:
    print_this("Estas en ASIG_SENT para símbolo");
    if(!error_detectat){
        VariableConstant aux_v1 = taulaSimbols.usarVariableConstant(v1.getValue());
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v2.getTipus() == TipusDades.NULL){
            print_this("Error semántico ASIG_SENT");
            String e = ("Valor no asignado");
            semantic_error(e, v2);
        }else{
            if(aux_v1.getValue() != ""){
                if(!aux_v1.isEsConstant()){
                    if(aux_v1.getTipus() != aux_v2.getTipus()){
                        print_this("Error semántico ASIG_SENT");
                        String e = ("Se está intentando asignar un tipo incorrecto a la variable " + v1.getValue());
                        semantic_error(e, v1);
                    }else{
                        aux_v1.setValor(aux_v2.getValor());
                        //if(aux_v1.getD() != -3){
                        //    t = c3a.novavar();
                        //    c3a.genera("prod", aux_v1.getD(), nbytes, t);
                        //    c3a.genera("ind_ass", aux_v2.getR(), t, aux_v1.getR());
                        //}else{
                            c3a.genera("copy", aux_v2.getR(), buid, aux_v1.getR()); //copy R.r = E.r
                        //}

                        RESULT = aux_v1;
                    }
                }else{
                    print_this("Error semántico ASIG_SENT");
                    String e = ("Se esta intentando asignar un nuevo valor a la constante " + v1.getValue());
                    semantic_error(e, v1);
                }
            }else{
                print_this("Error semántico ASIG_SENT");
                String e = ("La variable " + v1.getValue() + " no ha sido declarada");
                semantic_error(e, v1);
            }
        }
    }
:}
            | TUPLA_ACCESS:v1 assign EXP:v2 semicolon
{:
    print_this("Estas en ASIG_SENT para tupla");
    if(!error_detectat){
        Tupla aux_v1 = (Tupla) v1;
        Simbol aux_v2 = (Simbol) v2;
        print_this("Asignando valor a Tupla: "+ aux_v1.getValue());
        if(aux_v2.getTipus() == TipusDades.NULL){
            print_this("Error semántico ASIG_SENT");
            String e = ("Valor no asignado");
            semantic_error(e, v2);
        }else{
            if(aux_v1.getTipus() != aux_v2.getTipus()){
                print_this("Error semántico ASIG_SENT");
                String e = ("A la tupla " + aux_v1.getValue() + " se le esta asignando un tipo incorrecto.");
                semantic_error(e, v1);
            }else{
                aux_v1.setValor(aux_v2.getValor());
                if(aux_v1.getD() != -3){
                    t = c3a.novavar(aux_v1);
                    c3a.genera("prod", aux_v1.getD(), nbytes, t);           //t = i * nbytes
                    c3a.genera("ind_ass", aux_v2.getR(), t, aux_v1.getR()); //R.r[t] = E.r
                }else{
                    c3a.genera("copy", aux_v2.getR(), buid, aux_v1.getR()); //copy R.r = E.r
                }

                RESULT = aux_v1;
            }
        }
    }
:}
;

IF_SENT ::= IFINIT COS IFELSE COS endif
{:
    print_this("Estas en IF_SENT con else");
    if(!error_detectat){
        efi = c3a.getNe();                   //Obtenim la etiqueta creada a IFINIT o IFELSE que corerspon a efi
        c3a.genera("skip", buid, buid, efi); //efi: skip
    }
:}
          | IFINIT COS endif
{:
    print_this("Estas en IF_SENT sin else");
    if(!error_detectat){
        efi = c3a.getNe();                   //Obtenim la etiqueta creada a IFINIT que corerspon a efi
        c3a.genera("skip", buid, buid, efi); //efi: skip
    }
:}
;

IFINIT ::= if_t lparen EXP:v1 rparen colon
{:
    print_this("Estas en IFINIT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico IFINIT");
            String e = ("Debes asignar una condición al if");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico IFINIT");
                String e = ("La condición de la sentencia 'if' no es correcta");
                semantic_error(e, v1);
            }else{
                e = novaetiqueta();                       //Cream etiqueta que correspon a e o efi
                c3a.genera("if_EQ", aux_v1.getR(), 0, e); //if E.r=0 goto e

                RESULT = aux_v1;
            }
        }
    }
:}
;

IFELSE ::= else_t colon
{:
    print_this("Estas en IFELSE");
    if(!error_detectat){
        e_else = c3a.getNe();                   //Obtenim la etiqueta creada a IFINIT que correspon a inici de else
        e = c3a.novaetiqueta();                 //Etiqueta efi
        c3a.genera("goto", buid, buid, e);      //goto efi
        c3a.genera("skip", buid, buid, e_else); //e: skip
    }
:}
;

WHILE_SENT ::= while_t lparen EXP:v1 rparen colon COS endwhile
{:
    print_this("Estas en WHILE_SENT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico WHILE_SENT");
            String e = ("Debes asignar una condición al bucle");
            semantic_error(e, v1);
        }else{
            if(aux_v1.getTipus() != TipusDades.BOOLEAN){
                print_this("Error semántico WHILE_SENT");
                String e = ("La condición de la sentencia 'while' no es correcta");
                semantic_error(e, v1);
            }
        }
    }
:}
;

FOR_SENT ::= for_t FORINIT:v1 to FORLIMIT:v2 colon COS endfor
{:
    print_this("Estas en FOR_SENT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición init de la sentencia 'for' no es correcta");
            semantic_error(e, v1);
        }else if(aux_v2.getTipus() != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición limit de la sentencia 'for' no es correcta");
            semantic_error(e, v2);
        }
    }
:}
;

FORINIT ::= PARAM:v1 assign EXP:v2
{:
    print_this("Estas en FORINIT");
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() != aux_v2.getTipus()){
            print_this("Error semántico FORINIT");
            String e = ("Estas asignando un tipo incorrecto al parámetro del bucle for");
            semantic_error(e, v2);
        }else{
            RESULT = aux_v1;
        }
    }
:}
         | EXP:v1
{:
    print_this("Estas en FORINIT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORINIT");
            String e = ("Inicio del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:}
;

FORLIMIT ::= PARAM:v1 {: RESULT = v1;:}
           | EXP:v1
{:
    print_this("Estas en FORLIMIT");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico FORLIMIT");
            String e = ("Límite del bucle for no especificado");
            semantic_error(e, v1);
        }else{
            RESULT = aux_v1;
        }
    }
:}
;

SAL_SENT ::= out lparen OUT_EXP:v1 rparen semicolon
{:
    print_this("Estas en SAL_SENT");
    Simbol aux_v1 = (Simbol) v1;
    if(aux_v1.getTipus() == TipusDades.NULL){
        print_this("Error semántico SAL_SENT");
        String e = ("Salida vacía");
        semantic_error(e, v1);
    }else{
        RESULT = aux_v1;
    }
:}
;

OUT_EXP ::= CRID_SIMB:v1 {: print_this("Estas en OUT_EXP llamada a símbolo"); RESULT = v1; :}
          | ARIT_TERM:v1 {: print_this("Estas en OUT_EXP llamada a término aritmético"); RESULT = v1; :}
          | LOG_TERM:v1  {: print_this("Estas en OUT_EXP llamada a término lógico"); RESULT = v1; :}
          | LIT:v1       {: print_this("Estas en OUT_EXP llamada a literal"); RESULT = v1; :}
          ;

CRID_FUNC_SENT ::= id:v1 lparen ARGS:v2 rparen semicolon
{:
    print_this("Estas en CRID_FUNC_SENT para argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
        if(aux_v1.getValue() != ""){
            if(aux_v1.mateixosParametres(aux_v2)){
                RESULT = aux_v1;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + v1.getValue() + " no se le estan pasando los parámetros correctos");
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
            | id:v1 lparen rparen semicolon
{:
    print_this("Estas en CRID_FUNC_SENT sin argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        if(aux_v1.getValue() != ""){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
;

CRID_FUNC ::= id:v1 lparen ARGS:v2 rparen
{:

    print_this("Estas en CRID_FUNC para argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
        if(aux_v1.getValue() != ""){
            if(aux_v1.mateixosParametres(aux_v2)){
                RESULT = aux_v1;
            }else{
                print_this("Error semántico CRID_FUNC");
                String e = ("A la funcion " + v1.getValue() + " no se le estan pasando los parámetros correctos: "+aux_v2.toString());
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
            | id:v1 lparen rparen
{:
    print_this("Estas en CRID_FUNC sin argumentos");
    if(!error_detectat){
        print_this("Llamando a Función: "+ v1.getValue());
        Funcio aux_v1 = taulaSimbols.usarFuncio(v1.getValue());
        if(aux_v1.getValue() != ""){
            RESULT = aux_v1;
        }else{
            print_this("Error semántico CRID_FUNC");
            String e = ("La funcion " + v1.getValue() + " no ha sido creada");
            semantic_error(e, v1);
        }
    }
:}
;

FUNC_DECL ::= fnct TIPO:v1 id:v2 lparen PARAM_LIST:v3 rparen colon COS FINAL_RTN:v4 endfnct
{:

    print_this("Estas en FUNC_DECL con cuerpo");
    if(!error_detectat){
        print_this("Declarando Función: "+ v2.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        ArrayList<VariableConstant> aux_v3 = (ArrayList<VariableConstant>) v3;
        Simbol aux_v4 = (Simbol) v4;
        for(int i = 0; i < aux_v3.size() && !error_detectat; i++){
            print_this(aux_v3.get(i).toString());
        }
        if(!error_detectat){
            if(aux_v4.getTipus() != aux_v1.getTipus()){
                print_this("Error semántico FUNC_DECL");
                String e = ("El valor devuelto no corresponde con el tipo de la función.");
                semantic_error(e, v4);
            }
        }
        if(!error_detectat){
            error_detectat = !taulaSimbols.declararFuncio(new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus()));
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
                semantic_error(e, v2);
            }else{
                print_this("Función '" + v2.getValue() + " de tipo " + aux_v1.getTipus().toString() + " creada con éxito");
                RESULT = new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus());
            }
        }
    }
:}
            | fnct TIPO:v1 id:v2 lparen PARAM_LIST:v3 rparen colon FINAL_RTN:v4 endfnct
{:
    print_this("Estas en FUNC_DECL sin cuerpo");
    if(!error_detectat){
        print_this("Declarando Función: "+ v2.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        ArrayList<VariableConstant> aux_v3 = (ArrayList<VariableConstant>) v3;
        Simbol aux_v4 = (Simbol) v4;
        for(int i = 0; i < aux_v3.size() && !error_detectat; i++){
            print_this(aux_v3.get(i).toString());
        }
        if(!error_detectat){
            if(aux_v4.getTipus() != aux_v1.getTipus()){
                print_this("Error semántico FUNC_DECL");
                String e = ("El valor devuelto no corresponde con el tipo de la función.");
                semantic_error(e, v4);
            }
        }
        if(!error_detectat){
            error_detectat = !taulaSimbols.declararFuncio(new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus()));
            if(error_detectat){
                print_this("Error semántico FUNC_DECL");
                String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
                semantic_error(e, v2);
            }else{
                print_this("Función '" + v2.getValue() + " de tipo " + aux_v1.getTipus().toString() + " creada con éxito");
                RESULT = new Funcio(v2.getValue(), aux_v3, aux_v1.getTipus());
            }
        }
    }
:}
;

COS ::= SENT COS
      | SENT
      ;

FINAL_RTN ::= rtrn lparen EXP:v1 rparen semicolon
{:
    print_this("Estas en FINAL_RTN con cuerpo");
    Simbol aux_v1 = (Simbol) v1;
    if(aux_v1.getTipus() == TipusDades.NULL){
        print_this("Error semántico FINAL_RTN");
        String e = ("No se ha devuelto ningún valor");
        semantic_error(e, v1);
    }else{
        RESULT = aux_v1;
    }
:};

VAR_DECL ::= val id:v1 double_colon TIPO:v2 assign EXP:v3 semicolon
{:
    print_this("Estas en VAR_DECL");
    if(!error_detectat){
        print_this("Declarando Variable "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        if(aux_v3.getTipus() == TipusDades.NULL){
            print_this("Error semántico VAR_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, v3);
        }else{
            error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), false));
            if(error_detectat){
                print_this("Error semántico VAR_DECL");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Variable '" + v1.getValue() + "' creada con éxito");
                RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), false);
            }
        }
    }
:}
;

CONS_DECL ::= con id:v1 double_colon TIPO:v2 assign EXP:v3 semicolon
{:
    print_this("Estas en CONS_DECL");
    if(!error_detectat){
        print_this("Declarando Constante "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        if(aux_v3.getTipus() == TipusDades.NULL){
            print_this("Error semántico CONS_DECL");
            String e = ("Valor no asignado");
            semantic_error(e, v3);
        }else{
            error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), true));
            if(error_detectat){
                print_this("Error semántico CONS_DECL");
                String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
                semantic_error(e, v1);
            }else{
                print_this("Constante '" + v1.getValue() + "' creada con éxito");
                RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), true);
            }
        }
    }
:}
;

TUPLA_DECL ::= tuple id:v1 assign lbrace TIPO:v2 comma TIPO:v3 rbrace semicolon
{:
    print_this("Estas en TUPLA_DECL");
    if(!error_detectat){
        print_this("Declarando Tupla: "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        Simbol aux_v3 = (Simbol) v3;
        error_detectat = !taulaSimbols.declararTupla(new Tupla(v1.getValue(), aux_v2.getTipus(), aux_v3.getTipus()));
        if(error_detectat){
            print_this("Error semántico TUPLA_DECL");
            String e = ("Ya existe una tupla con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Tupla '" + v1.getValue() + "["+ aux_v2.getTipus().toString() +", "+ aux_v3.getTipus().toString() +"]' creada con éxito");
            RESULT = new Tupla(v1.getValue(), aux_v2.getTipus(), aux_v3.getTipus());
        }
    }
:}
;

EXP ::= LOG_TERM:v1     {: print_this("Estas en EXP termino lógico"); RESULT = v1; :}
      | ARIT_TERM:v1    {: print_this("Estas en EXP termino aritmético"); RESULT = v1; :}
      | CRID_SIMB:v1    {: print_this("Estas en EXP llamada a símbolo"); RESULT = v1; :}
      | LIT:v1          {: print_this("Estas en EXP llamada a literal"); RESULT = v1; :}
      | ENTR_FUNC:v1    {: print_this("Estas en EXP entrada de sistema"); RESULT = v1; :}
      ;

LIT ::= ENT_LIT:v1
{:
    print_this("Estas en LIT integer");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar(aux_v1);
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;
:}
      | BOL_LIT:v1
{:
    print_this("Estas en LIT booleano");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar(aux_v1);
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;
:}
;

ENT_LIT ::= POS_ENT_LIT:v1
{:
    print_this("Estas en ENT_LIT positivo");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar(aux_v1);
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;
:}
          | minus POS_ENT_LIT:v1
{:
    print_this("Estas en ENT_LIT negativo");
    Simbol aux_v1 = (Simbol) v1;
    aux_v1.setValor(-1*(Integer) aux_v1.getValue());

    int t = c3a.novavar(aux_v1);
    c3a.genera("neg", (Integer) aux_v1.getR(), buid, t);
    aux_v1.setR(t);


    aux_v1.setValor(-1*(Integer) aux_v1.getValue());
    RESULT = aux_v1;
:}
;

POS_ENT_LIT ::= integer_literal:v1
{:
    print_this("Positive integer");
    Simbol aux_v1 = (Simbol) v1;
    aux_v1.setValor((Integer) aux_v1.getValue());

    int t = c3a.novavar(aux_v1);
    c3a.genera("copy", (Integer) aux_v1.getValue(), buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;
:}
;

BOL_LIT ::= boolean_literal:v1
{:
    print_this("Boolean literal");
    Simbol aux_v1 = (Simbol) v1;
    if((String) aux_v1.getValue() == "TRUE" || (String) aux_v1.getValue() == "true"){
        aux_v1.setValor(0);
    }else{
        aux_v1.setValor(-1);
    }

    int t = c3a.novavar(aux_v1);
    c3a.genera("copy", val, buid, t);
    aux_v1.setR(t);

    RESULT = aux_v1;
:}
;

TUPLA_ACCESS ::= id:v1 lbracket integer_literal:v2 rbracket
{:
    print_this("Estas en TUPLA_ACCESS");
    if(!error_detectat){
        print_this("Accediendo a la Tupla: " + v1.getValue() + "(" + v2.getValue() + ")");
        Simbol aux_v1 = (Simbol) v1;
        Integer index = (Integer) v2.getValue();
        Tupla aux_tupla = taulaSimbols.usarTupla(v1.getValue());
        if(aux_tupla.getValue() != ""){
            if(index == 0 || index == 1){
                aux_tupla.setTipus(aux_tupla.getTipus(index));
                aux_tupla.setFila(aux_v1.getFila());
                aux_tupla.setColumna(aux_v1.getColumna());

                int t1 = c3a.novavar(new Simbol("t1", (Integer) v2.getValue()))
                c3a.genera("copy", (Integer) v2.getValue(), t1)
                int t2 = c3a.novavar(new Simbol("t2", (Integer) v2.getValue()) * nbytes)
                c3a.genera("prod", t1, nbytes, t2);
                aux_tupla.setD(t2);

                RESULT = aux_tupla;
            }else{
                print_this("Error semántico TUPLA_ACCESS");
                String e = ("El índice '" + index + "' de la tupla " + v1.getValue() + " no es correcto. Los índices de tupla solo permíten 0 o 1.");
                semantic_error(e, v2);
            }
        }else{
            print_this("Error semántico TUPLA_ACCESS");
            String e = ("La tupla " + v1.getValue() + " no ha sido declarada.");
            semantic_error(e, v1);
        }
    }
:}
;

TIPO ::= integer {: print_this("Tipo integer"); RESULT = new Simbol("integer", TipusDades.INTEGER, 1);//1 valor per tipus integer :}
       | logical {: print_this("Tipo boolean"); RESULT = new Simbol("logical", TipusDades.BOOLEAN, 2);//2 valor per tipus boolean :}
       ;

ARGS ::= EXP:v1 ARGS_LIST:v2
{:
    print_this("Estas en ARGS");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            RESULT = new ArrayList<Simbol>();
        }else{
            ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
            aux_v2.add(0, aux_v1);
            RESULT = aux_v2;
        }
    }
:}
;

ARGS_LIST ::= comma EXP:v1 ARGS_LIST:v2
{:
    print_this("Estas en ARGS_LIST");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico ARGS_LIST");
            String e = ("Argumento vacío");
            semantic_error(e, v1);
        }else{
            ArrayList<Simbol> aux_v2 = (ArrayList<Simbol>) v2;
            aux_v2.add(0, aux_v1);
            RESULT = aux_v2;
        }
    }
:}
            | /* epsilon */ {: print_this("Estas en ARGS_LIST epsilon"); RESULT = new ArrayList<Simbol>(); :}
            ;

PARAM_LIST ::= PARAM:v1
{:
    print_this("Estas en PARAM_LIST");
    if(!error_detectat){
        RESULT = new ArrayList<VariableConstant>(Arrays.asList((VariableConstant) v1));
    }
:}
             | PARAM:v1 comma PARAM_LIST:v2
{:
    print_this("Estas en PARAM_LIST");
    if(!error_detectat){
        VariableConstant aux_v1 = (VariableConstant) v1;
        ArrayList<VariableConstant> aux_v2 = (ArrayList<VariableConstant>) v2;
        aux_v2.add(0, aux_v1);
        RESULT = aux_v2;
    }
:}
             | /* epsilon */ {: print_this("Estas en PARAM_LIST epsilon"); RESULT = new ArrayList<VariableConstant>(); :}
             ;

PARAM ::= id:v1 double_colon TIPO:v2
{:
    print_this("Estas en PARAM");
    if(!error_detectat){
        print_this("Declarando Parámetro "+ v1.getValue());
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        error_detectat = !taulaSimbols.declararVariableConstant(new VariableConstant(v1.getValue(), aux_v2.getTipus(), false));
        if(error_detectat){
            print_this("Error semántico PARAM");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Parámetro '" + v1.getValue() + "' creado con éxito");
            RESULT = new VariableConstant(v1.getValue(), aux_v2.getTipus(), false);
        }
    }
:}
;

LOG_TERM ::= EXP:v1 equal EXP:v2
{:
    print_this("Estas en LOG_TERM equal");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
                if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                if(aux_v1.getTipus() == aux_v2.getTipus()){
                    print_this(aux_v1.getValue() + " equal " + aux_v2.getValue());

                    int t = c3a.novavar(new Simbol("t", buid));
                    int e1 = c3a.novaetiqueta();
                    int e2 = c3a.novaetiqueta();
                    c3a.genera("ifNE", aux_v1.getR(), aux_v2.getR(), e1);
                    c3a.genera("copy", 0, buid, t);
                    c3a.genera("goto", buid, buid, e2);
                    c3a.genera("skip", buid, buid, e1);
                    c3a.genera("copy", -1, buid, t);
                    c3a.genera("skip", buid, buid, e2);
                    RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t);
                }else{
                    print_this("Error semántico LOG_TERM");
                    String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
                    semantic_error(e, v1);
                }
            }
        }
    }
:}
           | EXP:v1 not_equal EXP:v2
{:
    print_this("Estas en LOG_TERM not equal");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                if(aux_v1.getTipus() == aux_v2.getTipus()){
                    print_this(aux_v1.getValue() + " not_equal "+aux_v2.getValue());

                    int t = c3a.novavar(new Simbol("t", buid));
                    int e1 = c3a.novaetiqueta();
                    int e2 = c3a.novaetiqueta();
                    c3a.genera("ifEQ", aux_v1.getR(), aux_v2.getR(), e1);
                    c3a.genera("copy", 0, buid, t);
                    c3a.genera("goto", buid, buid, e2);
                    c3a.genera("skip", buid, buid, e1);
                    c3a.genera("copy", -1, buid, t);
                    c3a.genera("skip", buid, buid, e2);
                    RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t);
                }else{
                    print_this("Error semántico LOG_TERM");
                    String e = (aux_v1.getValue() + " no es del mismo tipo que " + aux_v2.getValue());
                    semantic_error(e, v1);
                }
            }
        }
    }
:}
           | EXP:v1 and EXP:v2
{:
    print_this("Estas en LOG_TERM and");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                print_this(aux_v1.getValue() + " and " + aux_v2.getValue());
                int val = (aux_v1.getValor() == 0 ? 0 : (aux_v1.getValor() == 0 ? 0 : -1);
                int t = c3a.novavar(new Simbol("t"), val));
                c3a.genera("and", aux_v1.getR(), aux_v2.getR(), t);
                RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t, val);
            }
        }
    }
:}
           | EXP:v1 or EXP:v2
{:
    print_this("Estas en LOG_TERM or");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.NULL){
            print_this("Error semántico LOG_TERM");
            String e = ("Factor lógico vacío");
            semantic_error(e, v1);
        }else{
            if(aux_v2.getTipus() == TipusDades.NULL){
                print_this("Error semántico LOG_TERM");
                String e = ("Factor lógico vacío");
                semantic_error(e, v2);
            }else{
                print_this(aux_v1.getValue() + " or " + aux_v2.getValue());
                int val = (aux_v1.getValor() == 0 ? 0 : (aux_v1.getValor() == 0 ? 0 : -1);
                int t = c3a.novavar(new Simbol("t"), val));
                c3a.genera("or", aux_v1.getR(), aux_v2.getR(), t);
                RESULT = new Simbol(aux_v1.getFila(), aux_v1.getColumna(), aux_v1.getValue(), TipusDades.BOOLEAN, t, val);
            }
        }
    }
:}
;

ARIT_TERM ::= EXP:v1 plus EXP:v2
{:
    print_this("Estas en ARIT_TERM");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == TipusDades.INTEGER || aux_v2.getTipus() ==  TipusDades.INTEGER){

            int t = c3a.novavar(new Simbol("t"), aux_v1.getValor() + aux_v2.getValor()));
            c3a.genera("add", aux_v1.getR(), aux_v2.getR(), t);
            aux_v1.setR(t);

            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = ("El término aritmético solo puede sumar tipos integer");
            semantic_error(e, aux_v1);
        }
    }
:}
           | EXP:v1 minus EXP:v2
{:
    print_this("Estas en ARIT_TERM");
    if(!error_detectat){
        Simbol aux_v1 = (Simbol) v1;
        Simbol aux_v2 = (Simbol) v2;
        if(aux_v1.getTipus() == aux_v2.getTipus() || aux_v2.getTipus() ==  TipusDades.NULL){

            int t = c3a.novavar(new Simbol("t"), aux_v1.getValor() - aux_v2.getValor()));
            c3a.genera("sub", aux_v1.getR(), aux_v2.getR(), t);
            aux_v1.setR(t);

            RESULT = aux_v1;
        }else{
            print_this("Error semántico ARIT_TERM");
            String e = ("El término aritmético solo puede restar tipos integer");
            semantic_error(e, aux_v1);
        }
    }
:}
;

ENTR_FUNC ::= in lparen TIPO:v1 rparen
{:
    print_this("Estas en ENTR_FUNC");
    Simbol aux_v1 = (Simbol) v1;

    int d0 = c3a.novavar(aux_v1);
    c3a.genera("copy", aux_v1.getValor(), buid, d0);
    int d1 = c3a.novavar(new Simbol("d1"), buid);
    c3a.genera("in", d0, buid, d1);
    aux_v1.setR(d1);

    RESULT = aux_v1;
:};

CRID_SIMB ::= id:v1
{:
    print_this("Estas en CRID_SIMB id");
    Simbol aux_v1 = taulaSimbols.usarSimbol(v1.getValue()); //d = consulta(ts, id.id);
    if(aux_v1.getValue() != ""){

        if (aux_v1 instanceof VariableConstant) {
            aux_v1.setR(aux_v1.getR()); //d.nv té el número de variable
        } else {
            int t = c3a.novavar(aux_v1);
            c3a.genera("copy", aux_v1.getValor(), buid, t);
            aux_v1.setR(t);
        }
        aux_v1.setD(-3);

        RESULT = aux_v1;
    }else{
        print_this("Error semántico EXP");
        String e = ("El símbolo llamado no ha sido declarado");
        semantic_error(e, v1);
    }
:}
            | CRID_FUNC:v1
{:
    print_this("Estas en CRID_SIMB funcion");
    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar(aux_v1);
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;
:}
            | TUPLA_ACCESS:v1
{:
    print_this("Estas en CRID_SIMB tupla");

    Simbol aux_v1 = (Simbol) v1;

    if(aux_v1.getD() == -3){
        aux_v1.setR(aux_v1.getR());
    }else{
        int t = c3a.novavar(aux_v1);
        c3a.genera("idx_val", aux_v1.getR(), aux_v1.getD(), t);
        aux_v1.setR(t);
    }

    RESULT = aux_v1;
:}
;
