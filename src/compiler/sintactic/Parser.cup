package compiler.sintactic;
/**
 * parser.cup
 *
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica
 *
 * Marc Llobera Villalonga
 */

import java.lang.Exception;
import java_cup.runtime.*;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import compiler.sintactic.Symbols.*;

class Parser;

parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/

    TaulaSimbols taulaSimbols = new TaulaSimbols();
    ArrayList<Simbol> parametres_decl_func = new ArrayList<Simbol>();

    public boolean error_detectat = false;

    public boolean DEBUG = true;
    public void print_this(String msg){
        if(DEBUG){
            System.out.println(msg);
        }
    }

    public boolean declararVariableConstant(Object id, String tipus, boolean constant){
        try{
            return taulaSimbols.declararVariableConstant(id, tipus, constant);
        }catch(Exception e){
            System.err.println(e);
        }
        return false;
    }

    public boolean declararTupla(Object id, String tipus1, String tipus2){
        try{
            return taulaSimbols.declararTupla(id, tipus1, tipus2);
        }catch(Exception e){
            System.err.println(e);
        }
        return false;
    }

    public boolean declararFuncio(Object id, ArrayList<Simbol> parametres, String tipus){
        try{
            return taulaSimbols.declararFuncio(id, parametres, tipus);
        }catch(Exception e){
            System.err.println(e);
        }
        return false;
    }

    /**************************************************************
    ************************ GESTIÓ ERRORS ************************
    **************************************************************/

    @Override
    public void syntax_error(Symbol s) {
        report_error("Error sintáctico", s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws Exception {
        report_error("Error sintáctico inrrecuperable", s);
        done_parsing();
    }

    @Override
    public void report_error(String t, Object info) {
        print_this("Reportando error...");
        if(info instanceof Symbol){
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();

            print_error("Error en la linea " + l.getLine() + " y columna " + l.getColumn() + " --> " + t);
        }else{
            print_error("info no es Symbol en report_error");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal ("+message+")", info);
        done_parsing();
    }

    /**
    * Mètode per mostrar un error semàntic
    **/
    public void semantic_error(String t, Object info){
        print_this("Imprimiendo error semántico...");
        if(info instanceof Simbol){
            Simbol token = (Simbol) info;

            print_error("Error semántico en la linea " + token.getFila() + " y columna " + token.getColumna() + " --> " + t);
        }else{
            print_error("info no es Symbol en semantic_error");
        }
        done_parsing();
    }

    /**
    * Mètode per mostrar un error
    **/
    public void print_error(String msg){
        error_detectat = true;
        System.err.println("Error--> " + msg);
        done_parsing();
    }
:}

/* Definición de terminales (tokens) */
terminal Simbol fnct, endfnct, rtrn, val, con, if_t, else_t, endif, while_t, endwhile, for_t, to, endfor, in, out, tuple;
terminal Simbol integer, logical;
terminal Simbol assign, plus, minus, equal, not_equal, and, or;
terminal Simbol lparen, rparen, colon, double_colon, semicolon, comma, lbrace, rbrace, lbracket, rbracket;
terminal Simbol integer_literal;
terminal Simbol boolean_literal;
terminal Simbol id;

/* No terminales */
non terminal S, P, DECL, VAR_DECL, CONS_DECL, TUPLA_DECL, FUNC_DECL, PARAM_LIST, PARAM, COS, FINAL_RTN, SENT;
non terminal ASIG_SENT, IF_SENT, WHILE_SENT, FOR_SENT, FORINIT, FORLIMIT, TUPLA_ASSIGN, ENTR_SENT, SAL_SENT, CRID_FUNC, ARGS, ARGS_LIST;
non terminal TIPO, EXP, ARIT_TERM, ARIT_FACTOR, ARIT_TERM_REST, LOG_TERM, TUPLA_ACCESS, LIT, POS_ENT_LIT, NEG_ENT_LIT, BOL_LIT, OUT_EXP, ENTR_FUNC, SAL_FUNC;

/* Precedencia y asociatividad */
precedence left and, or;        // Menor precedencia
precedence left equal, not_equal; // Operadores relacionales === y /=
precedence left plus, minus;      // Operadores aritméticos + y -

/* Símbolo inicial */
start with S;

/* Reglas de gramática */

S ::= P ;

P ::= COS         {: :}
    | FUNC_DECL P {: :}
    | FUNC_DECL   {: :}
    ;

COS ::= SENT COS
      | SENT
      ;

SENT ::= DECL         {: :}
       | ASIG_SENT    {: :}
       | IF_SENT      {: :}
       | WHILE_SENT   {: :}
       | FOR_SENT     {: :}
       | TUPLA_ASSIGN {: :}
       | ENTR_SENT    {: :}
       | SAL_SENT     {: :}
       | CRID_FUNC    {: :}
       ;

DECL ::= VAR_DECL   {: :}
       | CONS_DECL  {: :}
       | TUPLA_DECL {: :}
       ;

ASIG_SENT ::= id:v1 assign EXP:v2 semicolon
{:
    if(!error_detectat){
        VariableConstant aux = taulaSimbols.usarVariableConstant(v1.getValue());
        if(aux != null){
            if(!aux.isEsConstant()){
                if(aux.getTipus().toString() != v2.toString()){
                    print_this("Error semántico ASIG_SENT");
                    String e = ("Se está intentando asignar un tipo incorrecto a la variable " + v1.getValue());
                    semantic_error(e, v1);
                }
            }else{
                print_this("Error semántico ASIG_SENT");
                String e = ("Se esta intentando asignar un nuevo valor a la constante " + v1.getValue());
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico ASIG_SENT");
            String e = ("La variable " + v1.getValue() + " no ha sido declarada");
            semantic_error(e, v1);
        }
    }
:}
;

IF_SENT ::= if_t:v1 lparen EXP:v2 rparen colon COS else_t colon COS endif
{:
    if(!error_detectat){
        if(v2 != TipusDades.BOOLEAN){
            print_this("Error semántico IF_SENT");
            String e = ("La condición de la sentencia 'if' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
          | if_t:v1 lparen EXP:v2 rparen colon COS endif
{:
    if(!error_detectat){
        if(v2 != TipusDades.BOOLEAN){
            print_this("Error semántico IF_SENT");
            String e = ("La condición de la sentencia 'if' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
;

WHILE_SENT ::= while_t:v1 lparen EXP:v2 rparen colon COS endwhile
{:
    if(!error_detectat){
        if(v2 != TipusDades.BOOLEAN){
            print_this("Error semántico WHILE_SENT");
            String e = ("La condición de la sentencia 'while' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
;

FOR_SENT ::= for_t:v1 FORINIT:v2 to FORLIMIT:v3 colon COS endfor
{:
    if(!error_detectat){
        if(v2 != TipusDades.INTEGER || v3 != TipusDades.INTEGER){
            print_this("Error semántico FOR_SENT");
            String e = ("La condición de la sentencia 'for' no es correcta");
            semantic_error(e, v1);
        }
    }
:}
;

TUPLA_ASSIGN ::= TUPLA_ACCESS:v1 assign EXP:v2 semicolon
{:
    if(!error_detectat){
        VariableConstant aux = (VariableConstant) v1;
        if(aux.getTipus().toString() != v2.toString()){
            print_this("Error semántico TUPLA_ASSIGN");
            String e = ("A la tupla " + aux.getValue() + " se le esta asignando un tipo incorrecto.");
            semantic_error(e, aux);
        }
    }
:}
;

ENTR_SENT ::= in lparen TIPO rparen semicolon ;

SAL_SENT ::= out lparen OUT_EXP rparen semicolon ;

CRID_FUNC ::= id lparen ARGS rparen
            | id lparen rparen
            ;

FUNC_DECL ::= fnct TIPO:v1 id:v2 lparen PARAM_LIST rparen colon COS FINAL_RTN endfnct
{:
    if(!error_detectat){
        print_this("Declarando Función: '"+ v2.getValue() +"' de tipo '" + v1.toString() + "' y con los parámetros:");
        for(int i = 0; i < parametres_decl_func.size(); i++){
            VariableConstant aux = (VariableConstant)parametres_decl_func.get(i);
            print_this(aux.toString());
        }
        error_detectat = !declararFuncio(v2.getValue(), parametres_decl_func, v1.toString());
        parametres_decl_func = new ArrayList<Simbol>();
        if(error_detectat){
            print_this("Error semántico");
            String e = ("Ya existe una función con el nombre '" + v2.getValue() + "'");
            semantic_error(e, v2);
        }else{
            print_this("Función '" + v2.getValue() + " de tipo " + v1.toString() + " creada con éxito");
        }
    }
:}
            | fnct TIPO:v1 id:v2 lparen PARAM_LIST:v3 rparen colon FINAL_RTN endfnct
            ;

VAR_DECL ::= val id:v1 double_colon TIPO:v2 assign EXP semicolon
{:
    if(!error_detectat){
        print_this("Declarando Variable '"+ v1.getValue() +"' de tipo '" + v2.toString() + "'");
        error_detectat = !declararVariableConstant(v1.getValue(), v2.toString(), false);
        if(error_detectat){
            print_this("Error semántico");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Variable '" + v1.getValue() + "' creada con éxito");
        }
    }

    RESULT = new VariableConstant(v1.toString(), v2.toString(), false);
:}
;

CONS_DECL ::= con id:v1 double_colon TIPO:v2 assign EXP semicolon
{:
    if(!error_detectat){
        print_this("Declarando Constante '"+ v1.getValue() +"' de tipo '" + v2.toString() + "'");
        error_detectat = !declararVariableConstant(v1.getValue(), v2.toString(), true);
        if(error_detectat){
            print_this("Error semántico");
            String e = ("Ya existe una variable o constante con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Constante '" + v1.getValue() + "' creada con éxito");
        }
    }

     RESULT = new VariableConstant(v1.toString(), v2.toString(), true);
:}
;

TUPLA_DECL ::= tuple id:v1 assign lbrace TIPO:v2 comma TIPO:v3 rbrace semicolon
{:
    if(!error_detectat){
        print_this("Declarando Tupla: '"+ v1.getValue() +"' de [tipo1: "+ v2.toString() +", tipo2: "+ v3.toString() +"]");
        error_detectat = !declararTupla(v1.getValue(), v2.toString(), v3.toString());
        if(error_detectat){
            print_this("Error semántico");
            String e = ("Ya existe una tupla con el nombre '" + v1.getValue() + "'");
            semantic_error(e, v1);
        }else{
            print_this("Tupla '" + v1.getValue() + "["+ v2.toString() +", "+ v3.toString() +"]' creada con éxito");
        }
    }

    RESULT = new Tupla(v1.toString(), v2.toString(), v3.toString());
:}
;

EXP ::= LOG_TERM
      | ARIT_TERM
      | CRID_FUNC
      | id
      | TUPLA_ACCESS
      | LIT
      | ENTR_FUNC
      | SAL_FUNC
      ;

FORINIT ::= VAR_DECL
         | EXP ;

FORLIMIT ::= CONS_DECL
           | EXP ;

TUPLA_ACCESS ::= id:v1 lbracket integer_literal:v2 rbracket
{:
    if(!error_detectat){
        Tupla aux = taulaSimbols.usarTupla(v1.getValue());
        if(aux != null){
            Integer index = (Integer) v2.getValue();
            if(index == 0 || index == 1){
                RESULT = new VariableConstant(v1.getValue(), aux.getTipus(index), false, v1.getFila(), v1.getColumna());
            }else{
                print_this("Error semántico TUPLA_ACCESS");
                String e = ("El índice '" + index + "' de la tupla " + v1.getValue() + " no es correcto. Los índices de tupla solo permíten 0 o 1.");
                semantic_error(e, v1);
            }
        }else{
            print_this("Error semántico TUPLA_ACCESS");
                String e = ("La tupla " + v1.getValue() + " no ha sido declarada.");
                semantic_error(e, v1);
        }
    }
:}
;

TIPO ::= integer {: RESULT = TipusDades.INTEGER; :}
       | logical {: RESULT = TipusDades.BOOLEAN; :}
       ;

OUT_EXP ::= id          {:  :}
          | CRID_FUNC
          | ARIT_TERM
          | LOG_TERM ;

ARGS ::= EXP ARGS_LIST ;

PARAM_LIST ::= PARAM:v {: :}
             | PARAM comma PARAM_LIST {: :}
             | /* epsilon */
             ;

FINAL_RTN ::= rtrn lparen EXP rparen semicolon;

LOG_TERM ::= EXP equal EXP
           | EXP not_equal EXP
           | EXP and EXP
           | EXP or EXP ;

ARIT_TERM ::= ARIT_FACTOR ARIT_TERM_REST ;

LIT ::= NEG_ENT_LIT:v {: RESULT = v; :}
     | BOL_LIT:v      {: RESULT = v; :}
     ;

ENTR_FUNC ::= in lparen TIPO rparen ;

SAL_FUNC ::= out lparen OUT_EXP rparen ;

ARGS_LIST ::= comma EXP ARGS_LIST
            | /* epsilon */ ;

PARAM ::= id:v1 double_colon TIPO:v2 {: RESULT = parametres_decl_func.add(new VariableConstant(v1.getValue(), v2.toString(), false)); :};

ARIT_FACTOR ::= lparen EXP rparen
              | POS_ENT_LIT:v     {: RESULT = v; :}
              ;

ARIT_TERM_REST ::= plus ARIT_FACTOR ARIT_TERM_REST
                 | minus ARIT_FACTOR ARIT_TERM_REST
                 | /* epsilon */ ;

NEG_ENT_LIT ::= minus integer_literal:v {: RESULT = -1*(Integer)v.getValue(); :};

BOL_LIT ::= boolean_literal:v {: RESULT = v.getValue(); :};

POS_ENT_LIT ::= integer_literal:v {: RESULT = (Integer)v.getValue(); :};
